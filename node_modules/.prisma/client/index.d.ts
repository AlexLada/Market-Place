
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export interface PrismaPromise<A> extends Promise<A> {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Moderation
 * 
 */
export type Moderation = {
  id: number
  login: string
  password: string
}

/**
 * Model Report
 * 
 */
export type Report = {
  id: number
  title: string
  date: Date
  text: string
}

/**
 * Model DeliveryAddress
 * 
 */
export type DeliveryAddress = {
  id: number
  name: string
  address: string
}

/**
 * Model Client
 * 
 */
export type Client = {
  id: number
  name: string
  surname: string
  email: string
  phone: string | null
  password: string
  emailConfirmed: boolean
  createdAt: Date
  promocodes: string[]
  wishlist: number[]
}

/**
 * Model Order
 * 
 */
export type Order = {
  id: number
  clientId: number
  dateCreated: Date
  confirmSuccess: boolean
  adress: string
}

/**
 * Model ProductOnOrder
 * 
 */
export type ProductOnOrder = {
  id: number
  productId: number
  orderId: number
  quantity: number
  statusCode: number
}

/**
 * Model Review
 * 
 */
export type Review = {
  id: number
  productId: number
  clientId: number
  createdAt: Date
  lastEditTime: Date
  title: string
  text: string
  rating: number
  retailerAnswer: string | null
  answerCreatedAt: Date | null
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: number
  title: string
  amount: number
  price: number
  brand: string
  country: string | null
  expires: string | null
  wayToUse: string | null
  contain: string | null
  description: string
  storage: string
  note: string | null
  visible: boolean
  retailerId: number
  clicks: number
  createdAt: Date
}

/**
 * Model ProductImage
 * 
 */
export type ProductImage = {
  id: number
  path: string
  alt: string
  productId: number
}

/**
 * Model Category
 * 
 */
export type Category = {
  id: number
  name: string
  keywords: string[]
}

/**
 * Model Retailer
 * 
 */
export type Retailer = {
  id: number
  email: string
  emailConfirmed: boolean
  photo: string
  name: string
  surname: string
  patrinymic: string
  phone: string | null
  companyName: string
  city: string
  confirmed: boolean
  password: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Moderations
 * const moderations = await prisma.moderation.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Moderations
   * const moderations = await prisma.moderation.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.moderation`: Exposes CRUD operations for the **Moderation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Moderations
    * const moderations = await prisma.moderation.findMany()
    * ```
    */
  get moderation(): Prisma.ModerationDelegate<GlobalReject>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<GlobalReject>;

  /**
   * `prisma.deliveryAddress`: Exposes CRUD operations for the **DeliveryAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryAddresses
    * const deliveryAddresses = await prisma.deliveryAddress.findMany()
    * ```
    */
  get deliveryAddress(): Prisma.DeliveryAddressDelegate<GlobalReject>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<GlobalReject>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<GlobalReject>;

  /**
   * `prisma.productOnOrder`: Exposes CRUD operations for the **ProductOnOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductOnOrders
    * const productOnOrders = await prisma.productOnOrder.findMany()
    * ```
    */
  get productOnOrder(): Prisma.ProductOnOrderDelegate<GlobalReject>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.productImage`: Exposes CRUD operations for the **ProductImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductImages
    * const productImages = await prisma.productImage.findMany()
    * ```
    */
  get productImage(): Prisma.ProductImageDelegate<GlobalReject>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<GlobalReject>;

  /**
   * `prisma.retailer`: Exposes CRUD operations for the **Retailer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Retailers
    * const retailers = await prisma.retailer.findMany()
    * ```
    */
  get retailer(): Prisma.RetailerDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.9.0
   * Query Engine version: ceb5c99003b99c9ee2c1d2e618e359c14aef2ea5
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Moderation: 'Moderation',
    Report: 'Report',
    DeliveryAddress: 'DeliveryAddress',
    Client: 'Client',
    Order: 'Order',
    ProductOnOrder: 'ProductOnOrder',
    Review: 'Review',
    Product: 'Product',
    ProductImage: 'ProductImage',
    Category: 'Category',
    Retailer: 'Retailer'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClientCountOutputType
   */


  export type ClientCountOutputType = {
    orders: number
    reviews: number
  }

  export type ClientCountOutputTypeSelect = {
    orders?: boolean
    reviews?: boolean
  }

  export type ClientCountOutputTypeGetPayload<S extends boolean | null | undefined | ClientCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ClientCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ClientCountOutputTypeArgs)
    ? ClientCountOutputType 
    : S extends { select: any } & (ClientCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ClientCountOutputType ? ClientCountOutputType[P] : never
  } 
      : ClientCountOutputType




  // Custom InputTypes

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect | null
  }



  /**
   * Count Type OrderCountOutputType
   */


  export type OrderCountOutputType = {
    products: number
  }

  export type OrderCountOutputTypeSelect = {
    products?: boolean
  }

  export type OrderCountOutputTypeGetPayload<S extends boolean | null | undefined | OrderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OrderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OrderCountOutputTypeArgs)
    ? OrderCountOutputType 
    : S extends { select: any } & (OrderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OrderCountOutputType ? OrderCountOutputType[P] : never
  } 
      : OrderCountOutputType




  // Custom InputTypes

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    categories: number
    images: number
    reviews: number
    orders: number
  }

  export type ProductCountOutputTypeSelect = {
    categories?: boolean
    images?: boolean
    reviews?: boolean
    orders?: boolean
  }

  export type ProductCountOutputTypeGetPayload<S extends boolean | null | undefined | ProductCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProductCountOutputTypeArgs)
    ? ProductCountOutputType 
    : S extends { select: any } & (ProductCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProductCountOutputType ? ProductCountOutputType[P] : never
  } 
      : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Count Type CategoryCountOutputType
   */


  export type CategoryCountOutputType = {
    products: number
    retailers: number
  }

  export type CategoryCountOutputTypeSelect = {
    products?: boolean
    retailers?: boolean
  }

  export type CategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | CategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CategoryCountOutputTypeArgs)
    ? CategoryCountOutputType 
    : S extends { select: any } & (CategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CategoryCountOutputType ? CategoryCountOutputType[P] : never
  } 
      : CategoryCountOutputType




  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type RetailerCountOutputType
   */


  export type RetailerCountOutputType = {
    products: number
    categorys: number
  }

  export type RetailerCountOutputTypeSelect = {
    products?: boolean
    categorys?: boolean
  }

  export type RetailerCountOutputTypeGetPayload<S extends boolean | null | undefined | RetailerCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RetailerCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RetailerCountOutputTypeArgs)
    ? RetailerCountOutputType 
    : S extends { select: any } & (RetailerCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RetailerCountOutputType ? RetailerCountOutputType[P] : never
  } 
      : RetailerCountOutputType




  // Custom InputTypes

  /**
   * RetailerCountOutputType without action
   */
  export type RetailerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RetailerCountOutputType
     */
    select?: RetailerCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Moderation
   */


  export type AggregateModeration = {
    _count: ModerationCountAggregateOutputType | null
    _avg: ModerationAvgAggregateOutputType | null
    _sum: ModerationSumAggregateOutputType | null
    _min: ModerationMinAggregateOutputType | null
    _max: ModerationMaxAggregateOutputType | null
  }

  export type ModerationAvgAggregateOutputType = {
    id: number | null
  }

  export type ModerationSumAggregateOutputType = {
    id: number | null
  }

  export type ModerationMinAggregateOutputType = {
    id: number | null
    login: string | null
    password: string | null
  }

  export type ModerationMaxAggregateOutputType = {
    id: number | null
    login: string | null
    password: string | null
  }

  export type ModerationCountAggregateOutputType = {
    id: number
    login: number
    password: number
    _all: number
  }


  export type ModerationAvgAggregateInputType = {
    id?: true
  }

  export type ModerationSumAggregateInputType = {
    id?: true
  }

  export type ModerationMinAggregateInputType = {
    id?: true
    login?: true
    password?: true
  }

  export type ModerationMaxAggregateInputType = {
    id?: true
    login?: true
    password?: true
  }

  export type ModerationCountAggregateInputType = {
    id?: true
    login?: true
    password?: true
    _all?: true
  }

  export type ModerationAggregateArgs = {
    /**
     * Filter which Moderation to aggregate.
     */
    where?: ModerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moderations to fetch.
     */
    orderBy?: Enumerable<ModerationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moderations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moderations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Moderations
    **/
    _count?: true | ModerationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModerationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModerationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModerationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModerationMaxAggregateInputType
  }

  export type GetModerationAggregateType<T extends ModerationAggregateArgs> = {
        [P in keyof T & keyof AggregateModeration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModeration[P]>
      : GetScalarType<T[P], AggregateModeration[P]>
  }




  export type ModerationGroupByArgs = {
    where?: ModerationWhereInput
    orderBy?: Enumerable<ModerationOrderByWithAggregationInput>
    by: ModerationScalarFieldEnum[]
    having?: ModerationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModerationCountAggregateInputType | true
    _avg?: ModerationAvgAggregateInputType
    _sum?: ModerationSumAggregateInputType
    _min?: ModerationMinAggregateInputType
    _max?: ModerationMaxAggregateInputType
  }


  export type ModerationGroupByOutputType = {
    id: number
    login: string
    password: string
    _count: ModerationCountAggregateOutputType | null
    _avg: ModerationAvgAggregateOutputType | null
    _sum: ModerationSumAggregateOutputType | null
    _min: ModerationMinAggregateOutputType | null
    _max: ModerationMaxAggregateOutputType | null
  }

  type GetModerationGroupByPayload<T extends ModerationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ModerationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModerationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModerationGroupByOutputType[P]>
            : GetScalarType<T[P], ModerationGroupByOutputType[P]>
        }
      >
    >


  export type ModerationSelect = {
    id?: boolean
    login?: boolean
    password?: boolean
  }


  export type ModerationGetPayload<S extends boolean | null | undefined | ModerationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Moderation :
    S extends undefined ? never :
    S extends { include: any } & (ModerationArgs | ModerationFindManyArgs)
    ? Moderation 
    : S extends { select: any } & (ModerationArgs | ModerationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Moderation ? Moderation[P] : never
  } 
      : Moderation


  type ModerationCountArgs = 
    Omit<ModerationFindManyArgs, 'select' | 'include'> & {
      select?: ModerationCountAggregateInputType | true
    }

  export interface ModerationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Moderation that matches the filter.
     * @param {ModerationFindUniqueArgs} args - Arguments to find a Moderation
     * @example
     * // Get one Moderation
     * const moderation = await prisma.moderation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ModerationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ModerationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Moderation'> extends True ? Prisma__ModerationClient<ModerationGetPayload<T>> : Prisma__ModerationClient<ModerationGetPayload<T> | null, null>

    /**
     * Find one Moderation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ModerationFindUniqueOrThrowArgs} args - Arguments to find a Moderation
     * @example
     * // Get one Moderation
     * const moderation = await prisma.moderation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ModerationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ModerationFindUniqueOrThrowArgs>
    ): Prisma__ModerationClient<ModerationGetPayload<T>>

    /**
     * Find the first Moderation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationFindFirstArgs} args - Arguments to find a Moderation
     * @example
     * // Get one Moderation
     * const moderation = await prisma.moderation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ModerationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ModerationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Moderation'> extends True ? Prisma__ModerationClient<ModerationGetPayload<T>> : Prisma__ModerationClient<ModerationGetPayload<T> | null, null>

    /**
     * Find the first Moderation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationFindFirstOrThrowArgs} args - Arguments to find a Moderation
     * @example
     * // Get one Moderation
     * const moderation = await prisma.moderation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ModerationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ModerationFindFirstOrThrowArgs>
    ): Prisma__ModerationClient<ModerationGetPayload<T>>

    /**
     * Find zero or more Moderations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Moderations
     * const moderations = await prisma.moderation.findMany()
     * 
     * // Get first 10 Moderations
     * const moderations = await prisma.moderation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moderationWithIdOnly = await prisma.moderation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ModerationFindManyArgs>(
      args?: SelectSubset<T, ModerationFindManyArgs>
    ): PrismaPromise<Array<ModerationGetPayload<T>>>

    /**
     * Create a Moderation.
     * @param {ModerationCreateArgs} args - Arguments to create a Moderation.
     * @example
     * // Create one Moderation
     * const Moderation = await prisma.moderation.create({
     *   data: {
     *     // ... data to create a Moderation
     *   }
     * })
     * 
    **/
    create<T extends ModerationCreateArgs>(
      args: SelectSubset<T, ModerationCreateArgs>
    ): Prisma__ModerationClient<ModerationGetPayload<T>>

    /**
     * Create many Moderations.
     *     @param {ModerationCreateManyArgs} args - Arguments to create many Moderations.
     *     @example
     *     // Create many Moderations
     *     const moderation = await prisma.moderation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ModerationCreateManyArgs>(
      args?: SelectSubset<T, ModerationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Moderation.
     * @param {ModerationDeleteArgs} args - Arguments to delete one Moderation.
     * @example
     * // Delete one Moderation
     * const Moderation = await prisma.moderation.delete({
     *   where: {
     *     // ... filter to delete one Moderation
     *   }
     * })
     * 
    **/
    delete<T extends ModerationDeleteArgs>(
      args: SelectSubset<T, ModerationDeleteArgs>
    ): Prisma__ModerationClient<ModerationGetPayload<T>>

    /**
     * Update one Moderation.
     * @param {ModerationUpdateArgs} args - Arguments to update one Moderation.
     * @example
     * // Update one Moderation
     * const moderation = await prisma.moderation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ModerationUpdateArgs>(
      args: SelectSubset<T, ModerationUpdateArgs>
    ): Prisma__ModerationClient<ModerationGetPayload<T>>

    /**
     * Delete zero or more Moderations.
     * @param {ModerationDeleteManyArgs} args - Arguments to filter Moderations to delete.
     * @example
     * // Delete a few Moderations
     * const { count } = await prisma.moderation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ModerationDeleteManyArgs>(
      args?: SelectSubset<T, ModerationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Moderations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Moderations
     * const moderation = await prisma.moderation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ModerationUpdateManyArgs>(
      args: SelectSubset<T, ModerationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Moderation.
     * @param {ModerationUpsertArgs} args - Arguments to update or create a Moderation.
     * @example
     * // Update or create a Moderation
     * const moderation = await prisma.moderation.upsert({
     *   create: {
     *     // ... data to create a Moderation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Moderation we want to update
     *   }
     * })
    **/
    upsert<T extends ModerationUpsertArgs>(
      args: SelectSubset<T, ModerationUpsertArgs>
    ): Prisma__ModerationClient<ModerationGetPayload<T>>

    /**
     * Count the number of Moderations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationCountArgs} args - Arguments to filter Moderations to count.
     * @example
     * // Count the number of Moderations
     * const count = await prisma.moderation.count({
     *   where: {
     *     // ... the filter for the Moderations we want to count
     *   }
     * })
    **/
    count<T extends ModerationCountArgs>(
      args?: Subset<T, ModerationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModerationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Moderation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModerationAggregateArgs>(args: Subset<T, ModerationAggregateArgs>): PrismaPromise<GetModerationAggregateType<T>>

    /**
     * Group by Moderation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModerationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModerationGroupByArgs['orderBy'] }
        : { orderBy?: ModerationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModerationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModerationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Moderation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ModerationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Moderation base type for findUnique actions
   */
  export type ModerationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Moderation
     */
    select?: ModerationSelect | null
    /**
     * Filter, which Moderation to fetch.
     */
    where: ModerationWhereUniqueInput
  }

  /**
   * Moderation findUnique
   */
  export interface ModerationFindUniqueArgs extends ModerationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Moderation findUniqueOrThrow
   */
  export type ModerationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Moderation
     */
    select?: ModerationSelect | null
    /**
     * Filter, which Moderation to fetch.
     */
    where: ModerationWhereUniqueInput
  }


  /**
   * Moderation base type for findFirst actions
   */
  export type ModerationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Moderation
     */
    select?: ModerationSelect | null
    /**
     * Filter, which Moderation to fetch.
     */
    where?: ModerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moderations to fetch.
     */
    orderBy?: Enumerable<ModerationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Moderations.
     */
    cursor?: ModerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moderations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moderations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Moderations.
     */
    distinct?: Enumerable<ModerationScalarFieldEnum>
  }

  /**
   * Moderation findFirst
   */
  export interface ModerationFindFirstArgs extends ModerationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Moderation findFirstOrThrow
   */
  export type ModerationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Moderation
     */
    select?: ModerationSelect | null
    /**
     * Filter, which Moderation to fetch.
     */
    where?: ModerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moderations to fetch.
     */
    orderBy?: Enumerable<ModerationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Moderations.
     */
    cursor?: ModerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moderations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moderations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Moderations.
     */
    distinct?: Enumerable<ModerationScalarFieldEnum>
  }


  /**
   * Moderation findMany
   */
  export type ModerationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Moderation
     */
    select?: ModerationSelect | null
    /**
     * Filter, which Moderations to fetch.
     */
    where?: ModerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moderations to fetch.
     */
    orderBy?: Enumerable<ModerationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Moderations.
     */
    cursor?: ModerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moderations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moderations.
     */
    skip?: number
    distinct?: Enumerable<ModerationScalarFieldEnum>
  }


  /**
   * Moderation create
   */
  export type ModerationCreateArgs = {
    /**
     * Select specific fields to fetch from the Moderation
     */
    select?: ModerationSelect | null
    /**
     * The data needed to create a Moderation.
     */
    data: XOR<ModerationCreateInput, ModerationUncheckedCreateInput>
  }


  /**
   * Moderation createMany
   */
  export type ModerationCreateManyArgs = {
    /**
     * The data used to create many Moderations.
     */
    data: Enumerable<ModerationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Moderation update
   */
  export type ModerationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Moderation
     */
    select?: ModerationSelect | null
    /**
     * The data needed to update a Moderation.
     */
    data: XOR<ModerationUpdateInput, ModerationUncheckedUpdateInput>
    /**
     * Choose, which Moderation to update.
     */
    where: ModerationWhereUniqueInput
  }


  /**
   * Moderation updateMany
   */
  export type ModerationUpdateManyArgs = {
    /**
     * The data used to update Moderations.
     */
    data: XOR<ModerationUpdateManyMutationInput, ModerationUncheckedUpdateManyInput>
    /**
     * Filter which Moderations to update
     */
    where?: ModerationWhereInput
  }


  /**
   * Moderation upsert
   */
  export type ModerationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Moderation
     */
    select?: ModerationSelect | null
    /**
     * The filter to search for the Moderation to update in case it exists.
     */
    where: ModerationWhereUniqueInput
    /**
     * In case the Moderation found by the `where` argument doesn't exist, create a new Moderation with this data.
     */
    create: XOR<ModerationCreateInput, ModerationUncheckedCreateInput>
    /**
     * In case the Moderation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModerationUpdateInput, ModerationUncheckedUpdateInput>
  }


  /**
   * Moderation delete
   */
  export type ModerationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Moderation
     */
    select?: ModerationSelect | null
    /**
     * Filter which Moderation to delete.
     */
    where: ModerationWhereUniqueInput
  }


  /**
   * Moderation deleteMany
   */
  export type ModerationDeleteManyArgs = {
    /**
     * Filter which Moderations to delete
     */
    where?: ModerationWhereInput
  }


  /**
   * Moderation without action
   */
  export type ModerationArgs = {
    /**
     * Select specific fields to fetch from the Moderation
     */
    select?: ModerationSelect | null
  }



  /**
   * Model Report
   */


  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    id: number | null
  }

  export type ReportSumAggregateOutputType = {
    id: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: number | null
    title: string | null
    date: Date | null
    text: string | null
  }

  export type ReportMaxAggregateOutputType = {
    id: number | null
    title: string | null
    date: Date | null
    text: string | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    title: number
    date: number
    text: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    id?: true
  }

  export type ReportSumAggregateInputType = {
    id?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    title?: true
    date?: true
    text?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    title?: true
    date?: true
    text?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    title?: true
    date?: true
    text?: true
    _all?: true
  }

  export type ReportAggregateArgs = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: Enumerable<ReportOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs = {
    where?: ReportWhereInput
    orderBy?: Enumerable<ReportOrderByWithAggregationInput>
    by: ReportScalarFieldEnum[]
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }


  export type ReportGroupByOutputType = {
    id: number
    title: string
    date: Date
    text: string
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect = {
    id?: boolean
    title?: boolean
    date?: boolean
    text?: boolean
  }


  export type ReportGetPayload<S extends boolean | null | undefined | ReportArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Report :
    S extends undefined ? never :
    S extends { include: any } & (ReportArgs | ReportFindManyArgs)
    ? Report 
    : S extends { select: any } & (ReportArgs | ReportFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Report ? Report[P] : never
  } 
      : Report


  type ReportCountArgs = 
    Omit<ReportFindManyArgs, 'select' | 'include'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReportFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Report'> extends True ? Prisma__ReportClient<ReportGetPayload<T>> : Prisma__ReportClient<ReportGetPayload<T> | null, null>

    /**
     * Find one Report that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReportFindUniqueOrThrowArgs>
    ): Prisma__ReportClient<ReportGetPayload<T>>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReportFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Report'> extends True ? Prisma__ReportClient<ReportGetPayload<T>> : Prisma__ReportClient<ReportGetPayload<T> | null, null>

    /**
     * Find the first Report that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReportFindFirstOrThrowArgs>
    ): Prisma__ReportClient<ReportGetPayload<T>>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportFindManyArgs>(
      args?: SelectSubset<T, ReportFindManyArgs>
    ): PrismaPromise<Array<ReportGetPayload<T>>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
    **/
    create<T extends ReportCreateArgs>(
      args: SelectSubset<T, ReportCreateArgs>
    ): Prisma__ReportClient<ReportGetPayload<T>>

    /**
     * Create many Reports.
     *     @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     *     @example
     *     // Create many Reports
     *     const report = await prisma.report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportCreateManyArgs>(
      args?: SelectSubset<T, ReportCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
    **/
    delete<T extends ReportDeleteArgs>(
      args: SelectSubset<T, ReportDeleteArgs>
    ): Prisma__ReportClient<ReportGetPayload<T>>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportUpdateArgs>(
      args: SelectSubset<T, ReportUpdateArgs>
    ): Prisma__ReportClient<ReportGetPayload<T>>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportDeleteManyArgs>(
      args?: SelectSubset<T, ReportDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportUpdateManyArgs>(
      args: SelectSubset<T, ReportUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
    **/
    upsert<T extends ReportUpsertArgs>(
      args: SelectSubset<T, ReportUpsertArgs>
    ): Prisma__ReportClient<ReportGetPayload<T>>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReportClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Report base type for findUnique actions
   */
  export type ReportFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUnique
   */
  export interface ReportFindUniqueArgs extends ReportFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report base type for findFirst actions
   */
  export type ReportFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: Enumerable<ReportOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: Enumerable<ReportScalarFieldEnum>
  }

  /**
   * Report findFirst
   */
  export interface ReportFindFirstArgs extends ReportFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: Enumerable<ReportOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * Report findMany
   */
  export type ReportFindManyArgs = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: Enumerable<ReportOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * Report create
   */
  export type ReportCreateArgs = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }


  /**
   * Report createMany
   */
  export type ReportCreateManyArgs = {
    /**
     * The data used to create many Reports.
     */
    data: Enumerable<ReportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Report update
   */
  export type ReportUpdateArgs = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }


  /**
   * Report upsert
   */
  export type ReportUpsertArgs = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }


  /**
   * Report delete
   */
  export type ReportDeleteArgs = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }


  /**
   * Report without action
   */
  export type ReportArgs = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect | null
  }



  /**
   * Model DeliveryAddress
   */


  export type AggregateDeliveryAddress = {
    _count: DeliveryAddressCountAggregateOutputType | null
    _avg: DeliveryAddressAvgAggregateOutputType | null
    _sum: DeliveryAddressSumAggregateOutputType | null
    _min: DeliveryAddressMinAggregateOutputType | null
    _max: DeliveryAddressMaxAggregateOutputType | null
  }

  export type DeliveryAddressAvgAggregateOutputType = {
    id: number | null
  }

  export type DeliveryAddressSumAggregateOutputType = {
    id: number | null
  }

  export type DeliveryAddressMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
  }

  export type DeliveryAddressMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
  }

  export type DeliveryAddressCountAggregateOutputType = {
    id: number
    name: number
    address: number
    _all: number
  }


  export type DeliveryAddressAvgAggregateInputType = {
    id?: true
  }

  export type DeliveryAddressSumAggregateInputType = {
    id?: true
  }

  export type DeliveryAddressMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
  }

  export type DeliveryAddressMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
  }

  export type DeliveryAddressCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    _all?: true
  }

  export type DeliveryAddressAggregateArgs = {
    /**
     * Filter which DeliveryAddress to aggregate.
     */
    where?: DeliveryAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryAddresses to fetch.
     */
    orderBy?: Enumerable<DeliveryAddressOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryAddresses
    **/
    _count?: true | DeliveryAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryAddressMaxAggregateInputType
  }

  export type GetDeliveryAddressAggregateType<T extends DeliveryAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryAddress[P]>
      : GetScalarType<T[P], AggregateDeliveryAddress[P]>
  }




  export type DeliveryAddressGroupByArgs = {
    where?: DeliveryAddressWhereInput
    orderBy?: Enumerable<DeliveryAddressOrderByWithAggregationInput>
    by: DeliveryAddressScalarFieldEnum[]
    having?: DeliveryAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryAddressCountAggregateInputType | true
    _avg?: DeliveryAddressAvgAggregateInputType
    _sum?: DeliveryAddressSumAggregateInputType
    _min?: DeliveryAddressMinAggregateInputType
    _max?: DeliveryAddressMaxAggregateInputType
  }


  export type DeliveryAddressGroupByOutputType = {
    id: number
    name: string
    address: string
    _count: DeliveryAddressCountAggregateOutputType | null
    _avg: DeliveryAddressAvgAggregateOutputType | null
    _sum: DeliveryAddressSumAggregateOutputType | null
    _min: DeliveryAddressMinAggregateOutputType | null
    _max: DeliveryAddressMaxAggregateOutputType | null
  }

  type GetDeliveryAddressGroupByPayload<T extends DeliveryAddressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DeliveryAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryAddressGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryAddressGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryAddressSelect = {
    id?: boolean
    name?: boolean
    address?: boolean
  }


  export type DeliveryAddressGetPayload<S extends boolean | null | undefined | DeliveryAddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DeliveryAddress :
    S extends undefined ? never :
    S extends { include: any } & (DeliveryAddressArgs | DeliveryAddressFindManyArgs)
    ? DeliveryAddress 
    : S extends { select: any } & (DeliveryAddressArgs | DeliveryAddressFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DeliveryAddress ? DeliveryAddress[P] : never
  } 
      : DeliveryAddress


  type DeliveryAddressCountArgs = 
    Omit<DeliveryAddressFindManyArgs, 'select' | 'include'> & {
      select?: DeliveryAddressCountAggregateInputType | true
    }

  export interface DeliveryAddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DeliveryAddress that matches the filter.
     * @param {DeliveryAddressFindUniqueArgs} args - Arguments to find a DeliveryAddress
     * @example
     * // Get one DeliveryAddress
     * const deliveryAddress = await prisma.deliveryAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeliveryAddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeliveryAddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DeliveryAddress'> extends True ? Prisma__DeliveryAddressClient<DeliveryAddressGetPayload<T>> : Prisma__DeliveryAddressClient<DeliveryAddressGetPayload<T> | null, null>

    /**
     * Find one DeliveryAddress that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DeliveryAddressFindUniqueOrThrowArgs} args - Arguments to find a DeliveryAddress
     * @example
     * // Get one DeliveryAddress
     * const deliveryAddress = await prisma.deliveryAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeliveryAddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DeliveryAddressFindUniqueOrThrowArgs>
    ): Prisma__DeliveryAddressClient<DeliveryAddressGetPayload<T>>

    /**
     * Find the first DeliveryAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAddressFindFirstArgs} args - Arguments to find a DeliveryAddress
     * @example
     * // Get one DeliveryAddress
     * const deliveryAddress = await prisma.deliveryAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeliveryAddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeliveryAddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DeliveryAddress'> extends True ? Prisma__DeliveryAddressClient<DeliveryAddressGetPayload<T>> : Prisma__DeliveryAddressClient<DeliveryAddressGetPayload<T> | null, null>

    /**
     * Find the first DeliveryAddress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAddressFindFirstOrThrowArgs} args - Arguments to find a DeliveryAddress
     * @example
     * // Get one DeliveryAddress
     * const deliveryAddress = await prisma.deliveryAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeliveryAddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DeliveryAddressFindFirstOrThrowArgs>
    ): Prisma__DeliveryAddressClient<DeliveryAddressGetPayload<T>>

    /**
     * Find zero or more DeliveryAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryAddresses
     * const deliveryAddresses = await prisma.deliveryAddress.findMany()
     * 
     * // Get first 10 DeliveryAddresses
     * const deliveryAddresses = await prisma.deliveryAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryAddressWithIdOnly = await prisma.deliveryAddress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeliveryAddressFindManyArgs>(
      args?: SelectSubset<T, DeliveryAddressFindManyArgs>
    ): PrismaPromise<Array<DeliveryAddressGetPayload<T>>>

    /**
     * Create a DeliveryAddress.
     * @param {DeliveryAddressCreateArgs} args - Arguments to create a DeliveryAddress.
     * @example
     * // Create one DeliveryAddress
     * const DeliveryAddress = await prisma.deliveryAddress.create({
     *   data: {
     *     // ... data to create a DeliveryAddress
     *   }
     * })
     * 
    **/
    create<T extends DeliveryAddressCreateArgs>(
      args: SelectSubset<T, DeliveryAddressCreateArgs>
    ): Prisma__DeliveryAddressClient<DeliveryAddressGetPayload<T>>

    /**
     * Create many DeliveryAddresses.
     *     @param {DeliveryAddressCreateManyArgs} args - Arguments to create many DeliveryAddresses.
     *     @example
     *     // Create many DeliveryAddresses
     *     const deliveryAddress = await prisma.deliveryAddress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeliveryAddressCreateManyArgs>(
      args?: SelectSubset<T, DeliveryAddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DeliveryAddress.
     * @param {DeliveryAddressDeleteArgs} args - Arguments to delete one DeliveryAddress.
     * @example
     * // Delete one DeliveryAddress
     * const DeliveryAddress = await prisma.deliveryAddress.delete({
     *   where: {
     *     // ... filter to delete one DeliveryAddress
     *   }
     * })
     * 
    **/
    delete<T extends DeliveryAddressDeleteArgs>(
      args: SelectSubset<T, DeliveryAddressDeleteArgs>
    ): Prisma__DeliveryAddressClient<DeliveryAddressGetPayload<T>>

    /**
     * Update one DeliveryAddress.
     * @param {DeliveryAddressUpdateArgs} args - Arguments to update one DeliveryAddress.
     * @example
     * // Update one DeliveryAddress
     * const deliveryAddress = await prisma.deliveryAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeliveryAddressUpdateArgs>(
      args: SelectSubset<T, DeliveryAddressUpdateArgs>
    ): Prisma__DeliveryAddressClient<DeliveryAddressGetPayload<T>>

    /**
     * Delete zero or more DeliveryAddresses.
     * @param {DeliveryAddressDeleteManyArgs} args - Arguments to filter DeliveryAddresses to delete.
     * @example
     * // Delete a few DeliveryAddresses
     * const { count } = await prisma.deliveryAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeliveryAddressDeleteManyArgs>(
      args?: SelectSubset<T, DeliveryAddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryAddresses
     * const deliveryAddress = await prisma.deliveryAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeliveryAddressUpdateManyArgs>(
      args: SelectSubset<T, DeliveryAddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DeliveryAddress.
     * @param {DeliveryAddressUpsertArgs} args - Arguments to update or create a DeliveryAddress.
     * @example
     * // Update or create a DeliveryAddress
     * const deliveryAddress = await prisma.deliveryAddress.upsert({
     *   create: {
     *     // ... data to create a DeliveryAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryAddress we want to update
     *   }
     * })
    **/
    upsert<T extends DeliveryAddressUpsertArgs>(
      args: SelectSubset<T, DeliveryAddressUpsertArgs>
    ): Prisma__DeliveryAddressClient<DeliveryAddressGetPayload<T>>

    /**
     * Count the number of DeliveryAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAddressCountArgs} args - Arguments to filter DeliveryAddresses to count.
     * @example
     * // Count the number of DeliveryAddresses
     * const count = await prisma.deliveryAddress.count({
     *   where: {
     *     // ... the filter for the DeliveryAddresses we want to count
     *   }
     * })
    **/
    count<T extends DeliveryAddressCountArgs>(
      args?: Subset<T, DeliveryAddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryAddressAggregateArgs>(args: Subset<T, DeliveryAddressAggregateArgs>): PrismaPromise<GetDeliveryAddressAggregateType<T>>

    /**
     * Group by DeliveryAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryAddressGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryAddressGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeliveryAddressClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DeliveryAddress base type for findUnique actions
   */
  export type DeliveryAddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect | null
    /**
     * Filter, which DeliveryAddress to fetch.
     */
    where: DeliveryAddressWhereUniqueInput
  }

  /**
   * DeliveryAddress findUnique
   */
  export interface DeliveryAddressFindUniqueArgs extends DeliveryAddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeliveryAddress findUniqueOrThrow
   */
  export type DeliveryAddressFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect | null
    /**
     * Filter, which DeliveryAddress to fetch.
     */
    where: DeliveryAddressWhereUniqueInput
  }


  /**
   * DeliveryAddress base type for findFirst actions
   */
  export type DeliveryAddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect | null
    /**
     * Filter, which DeliveryAddress to fetch.
     */
    where?: DeliveryAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryAddresses to fetch.
     */
    orderBy?: Enumerable<DeliveryAddressOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryAddresses.
     */
    cursor?: DeliveryAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryAddresses.
     */
    distinct?: Enumerable<DeliveryAddressScalarFieldEnum>
  }

  /**
   * DeliveryAddress findFirst
   */
  export interface DeliveryAddressFindFirstArgs extends DeliveryAddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeliveryAddress findFirstOrThrow
   */
  export type DeliveryAddressFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect | null
    /**
     * Filter, which DeliveryAddress to fetch.
     */
    where?: DeliveryAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryAddresses to fetch.
     */
    orderBy?: Enumerable<DeliveryAddressOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryAddresses.
     */
    cursor?: DeliveryAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryAddresses.
     */
    distinct?: Enumerable<DeliveryAddressScalarFieldEnum>
  }


  /**
   * DeliveryAddress findMany
   */
  export type DeliveryAddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect | null
    /**
     * Filter, which DeliveryAddresses to fetch.
     */
    where?: DeliveryAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryAddresses to fetch.
     */
    orderBy?: Enumerable<DeliveryAddressOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryAddresses.
     */
    cursor?: DeliveryAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryAddresses.
     */
    skip?: number
    distinct?: Enumerable<DeliveryAddressScalarFieldEnum>
  }


  /**
   * DeliveryAddress create
   */
  export type DeliveryAddressCreateArgs = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect | null
    /**
     * The data needed to create a DeliveryAddress.
     */
    data: XOR<DeliveryAddressCreateInput, DeliveryAddressUncheckedCreateInput>
  }


  /**
   * DeliveryAddress createMany
   */
  export type DeliveryAddressCreateManyArgs = {
    /**
     * The data used to create many DeliveryAddresses.
     */
    data: Enumerable<DeliveryAddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DeliveryAddress update
   */
  export type DeliveryAddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect | null
    /**
     * The data needed to update a DeliveryAddress.
     */
    data: XOR<DeliveryAddressUpdateInput, DeliveryAddressUncheckedUpdateInput>
    /**
     * Choose, which DeliveryAddress to update.
     */
    where: DeliveryAddressWhereUniqueInput
  }


  /**
   * DeliveryAddress updateMany
   */
  export type DeliveryAddressUpdateManyArgs = {
    /**
     * The data used to update DeliveryAddresses.
     */
    data: XOR<DeliveryAddressUpdateManyMutationInput, DeliveryAddressUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryAddresses to update
     */
    where?: DeliveryAddressWhereInput
  }


  /**
   * DeliveryAddress upsert
   */
  export type DeliveryAddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect | null
    /**
     * The filter to search for the DeliveryAddress to update in case it exists.
     */
    where: DeliveryAddressWhereUniqueInput
    /**
     * In case the DeliveryAddress found by the `where` argument doesn't exist, create a new DeliveryAddress with this data.
     */
    create: XOR<DeliveryAddressCreateInput, DeliveryAddressUncheckedCreateInput>
    /**
     * In case the DeliveryAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryAddressUpdateInput, DeliveryAddressUncheckedUpdateInput>
  }


  /**
   * DeliveryAddress delete
   */
  export type DeliveryAddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect | null
    /**
     * Filter which DeliveryAddress to delete.
     */
    where: DeliveryAddressWhereUniqueInput
  }


  /**
   * DeliveryAddress deleteMany
   */
  export type DeliveryAddressDeleteManyArgs = {
    /**
     * Filter which DeliveryAddresses to delete
     */
    where?: DeliveryAddressWhereInput
  }


  /**
   * DeliveryAddress without action
   */
  export type DeliveryAddressArgs = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect | null
  }



  /**
   * Model Client
   */


  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id: number | null
    wishlist: number | null
  }

  export type ClientSumAggregateOutputType = {
    id: number | null
    wishlist: number[] | null
  }

  export type ClientMinAggregateOutputType = {
    id: number | null
    name: string | null
    surname: string | null
    email: string | null
    phone: string | null
    password: string | null
    emailConfirmed: boolean | null
    createdAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: number | null
    name: string | null
    surname: string | null
    email: string | null
    phone: string | null
    password: string | null
    emailConfirmed: boolean | null
    createdAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    surname: number
    email: number
    phone: number
    password: number
    emailConfirmed: number
    createdAt: number
    promocodes: number
    wishlist: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id?: true
    wishlist?: true
  }

  export type ClientSumAggregateInputType = {
    id?: true
    wishlist?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    email?: true
    phone?: true
    password?: true
    emailConfirmed?: true
    createdAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    email?: true
    phone?: true
    password?: true
    emailConfirmed?: true
    createdAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    email?: true
    phone?: true
    password?: true
    emailConfirmed?: true
    createdAt?: true
    promocodes?: true
    wishlist?: true
    _all?: true
  }

  export type ClientAggregateArgs = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: Enumerable<ClientOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs = {
    where?: ClientWhereInput
    orderBy?: Enumerable<ClientOrderByWithAggregationInput>
    by: ClientScalarFieldEnum[]
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }


  export type ClientGroupByOutputType = {
    id: number
    name: string
    surname: string
    email: string
    phone: string | null
    password: string
    emailConfirmed: boolean
    createdAt: Date
    promocodes: string[]
    wishlist: number[]
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect = {
    id?: boolean
    name?: boolean
    surname?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    emailConfirmed?: boolean
    createdAt?: boolean
    promocodes?: boolean
    wishlist?: boolean
    orders?: boolean | Client$ordersArgs
    reviews?: boolean | Client$reviewsArgs
    _count?: boolean | ClientCountOutputTypeArgs
  }


  export type ClientInclude = {
    orders?: boolean | Client$ordersArgs
    reviews?: boolean | Client$reviewsArgs
    _count?: boolean | ClientCountOutputTypeArgs
  }

  export type ClientGetPayload<S extends boolean | null | undefined | ClientArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Client :
    S extends undefined ? never :
    S extends { include: any } & (ClientArgs | ClientFindManyArgs)
    ? Client  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'orders' ? Array < OrderGetPayload<S['include'][P]>>  :
        P extends 'reviews' ? Array < ReviewGetPayload<S['include'][P]>>  :
        P extends '_count' ? ClientCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ClientArgs | ClientFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'orders' ? Array < OrderGetPayload<S['select'][P]>>  :
        P extends 'reviews' ? Array < ReviewGetPayload<S['select'][P]>>  :
        P extends '_count' ? ClientCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Client ? Client[P] : never
  } 
      : Client


  type ClientCountArgs = 
    Omit<ClientFindManyArgs, 'select' | 'include'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Client'> extends True ? Prisma__ClientClient<ClientGetPayload<T>> : Prisma__ClientClient<ClientGetPayload<T> | null, null>

    /**
     * Find one Client that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ClientFindUniqueOrThrowArgs>
    ): Prisma__ClientClient<ClientGetPayload<T>>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Client'> extends True ? Prisma__ClientClient<ClientGetPayload<T>> : Prisma__ClientClient<ClientGetPayload<T> | null, null>

    /**
     * Find the first Client that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClientFindFirstOrThrowArgs>
    ): Prisma__ClientClient<ClientGetPayload<T>>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientFindManyArgs>(
      args?: SelectSubset<T, ClientFindManyArgs>
    ): PrismaPromise<Array<ClientGetPayload<T>>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
    **/
    create<T extends ClientCreateArgs>(
      args: SelectSubset<T, ClientCreateArgs>
    ): Prisma__ClientClient<ClientGetPayload<T>>

    /**
     * Create many Clients.
     *     @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     *     @example
     *     // Create many Clients
     *     const client = await prisma.client.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClientCreateManyArgs>(
      args?: SelectSubset<T, ClientCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
    **/
    delete<T extends ClientDeleteArgs>(
      args: SelectSubset<T, ClientDeleteArgs>
    ): Prisma__ClientClient<ClientGetPayload<T>>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientUpdateArgs>(
      args: SelectSubset<T, ClientUpdateArgs>
    ): Prisma__ClientClient<ClientGetPayload<T>>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientDeleteManyArgs>(
      args?: SelectSubset<T, ClientDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientUpdateManyArgs>(
      args: SelectSubset<T, ClientUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
    **/
    upsert<T extends ClientUpsertArgs>(
      args: SelectSubset<T, ClientUpsertArgs>
    ): Prisma__ClientClient<ClientGetPayload<T>>

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClientClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    orders<T extends Client$ordersArgs= {}>(args?: Subset<T, Client$ordersArgs>): PrismaPromise<Array<OrderGetPayload<T>>| Null>;

    reviews<T extends Client$reviewsArgs= {}>(args?: Subset<T, Client$reviewsArgs>): PrismaPromise<Array<ReviewGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Client base type for findUnique actions
   */
  export type ClientFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUnique
   */
  export interface ClientFindUniqueArgs extends ClientFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }


  /**
   * Client base type for findFirst actions
   */
  export type ClientFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: Enumerable<ClientOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: Enumerable<ClientScalarFieldEnum>
  }

  /**
   * Client findFirst
   */
  export interface ClientFindFirstArgs extends ClientFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: Enumerable<ClientOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: Enumerable<ClientScalarFieldEnum>
  }


  /**
   * Client findMany
   */
  export type ClientFindManyArgs = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: Enumerable<ClientOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: Enumerable<ClientScalarFieldEnum>
  }


  /**
   * Client create
   */
  export type ClientCreateArgs = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }


  /**
   * Client createMany
   */
  export type ClientCreateManyArgs = {
    /**
     * The data used to create many Clients.
     */
    data: Enumerable<ClientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Client update
   */
  export type ClientUpdateArgs = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }


  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }


  /**
   * Client upsert
   */
  export type ClientUpsertArgs = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }


  /**
   * Client delete
   */
  export type ClientDeleteArgs = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }


  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }


  /**
   * Client.orders
   */
  export type Client$ordersArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithRelationAndSearchRelevanceInput>
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Client.reviews
   */
  export type Client$reviewsArgs = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude | null
    where?: ReviewWhereInput
    orderBy?: Enumerable<ReviewOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * Client without action
   */
  export type ClientArgs = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude | null
  }



  /**
   * Model Order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    clientId: number | null
    dateCreated: Date | null
    confirmSuccess: boolean | null
    adress: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    clientId: number | null
    dateCreated: Date | null
    confirmSuccess: boolean | null
    adress: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    clientId: number
    dateCreated: number
    confirmSuccess: number
    adress: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    clientId?: true
    dateCreated?: true
    confirmSuccess?: true
    adress?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    clientId?: true
    dateCreated?: true
    confirmSuccess?: true
    adress?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    clientId?: true
    dateCreated?: true
    confirmSuccess?: true
    adress?: true
    _all?: true
  }

  export type OrderAggregateArgs = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs = {
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithAggregationInput>
    by: OrderScalarFieldEnum[]
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: number
    clientId: number
    dateCreated: Date
    confirmSuccess: boolean
    adress: string
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect = {
    id?: boolean
    clientId?: boolean
    client?: boolean | ClientArgs
    dateCreated?: boolean
    confirmSuccess?: boolean
    products?: boolean | Order$productsArgs
    adress?: boolean
    _count?: boolean | OrderCountOutputTypeArgs
  }


  export type OrderInclude = {
    client?: boolean | ClientArgs
    products?: boolean | Order$productsArgs
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderGetPayload<S extends boolean | null | undefined | OrderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Order :
    S extends undefined ? never :
    S extends { include: any } & (OrderArgs | OrderFindManyArgs)
    ? Order  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'client' ? ClientGetPayload<S['include'][P]> :
        P extends 'products' ? Array < ProductOnOrderGetPayload<S['include'][P]>>  :
        P extends '_count' ? OrderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OrderArgs | OrderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'client' ? ClientGetPayload<S['select'][P]> :
        P extends 'products' ? Array < ProductOnOrderGetPayload<S['select'][P]>>  :
        P extends '_count' ? OrderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Order ? Order[P] : never
  } 
      : Order


  type OrderCountArgs = 
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Order'> extends True ? Prisma__OrderClient<OrderGetPayload<T>> : Prisma__OrderClient<OrderGetPayload<T> | null, null>

    /**
     * Find one Order that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Order'> extends True ? Prisma__OrderClient<OrderGetPayload<T>> : Prisma__OrderClient<OrderGetPayload<T> | null, null>

    /**
     * Find the first Order that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs>
    ): PrismaPromise<Array<OrderGetPayload<T>>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    client<T extends ClientArgs= {}>(args?: Subset<T, ClientArgs>): Prisma__ClientClient<ClientGetPayload<T> | Null>;

    products<T extends Order$productsArgs= {}>(args?: Subset<T, Order$productsArgs>): PrismaPromise<Array<ProductOnOrderGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Order base type for findUnique actions
   */
  export type OrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUnique
   */
  export interface OrderFindUniqueArgs extends OrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order base type for findFirst actions
   */
  export type OrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: Enumerable<OrderScalarFieldEnum>
  }

  /**
   * Order findFirst
   */
  export interface OrderFindFirstArgs extends OrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order findMany
   */
  export type OrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order create
   */
  export type OrderCreateArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs = {
    /**
     * The data used to create many Orders.
     */
    data: Enumerable<OrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }


  /**
   * Order.products
   */
  export type Order$productsArgs = {
    /**
     * Select specific fields to fetch from the ProductOnOrder
     */
    select?: ProductOnOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOnOrderInclude | null
    where?: ProductOnOrderWhereInput
    orderBy?: Enumerable<ProductOnOrderOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ProductOnOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductOnOrderScalarFieldEnum>
  }


  /**
   * Order without action
   */
  export type OrderArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
  }



  /**
   * Model ProductOnOrder
   */


  export type AggregateProductOnOrder = {
    _count: ProductOnOrderCountAggregateOutputType | null
    _avg: ProductOnOrderAvgAggregateOutputType | null
    _sum: ProductOnOrderSumAggregateOutputType | null
    _min: ProductOnOrderMinAggregateOutputType | null
    _max: ProductOnOrderMaxAggregateOutputType | null
  }

  export type ProductOnOrderAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    orderId: number | null
    quantity: number | null
    statusCode: number | null
  }

  export type ProductOnOrderSumAggregateOutputType = {
    id: number | null
    productId: number | null
    orderId: number | null
    quantity: number | null
    statusCode: number | null
  }

  export type ProductOnOrderMinAggregateOutputType = {
    id: number | null
    productId: number | null
    orderId: number | null
    quantity: number | null
    statusCode: number | null
  }

  export type ProductOnOrderMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    orderId: number | null
    quantity: number | null
    statusCode: number | null
  }

  export type ProductOnOrderCountAggregateOutputType = {
    id: number
    productId: number
    orderId: number
    quantity: number
    statusCode: number
    _all: number
  }


  export type ProductOnOrderAvgAggregateInputType = {
    id?: true
    productId?: true
    orderId?: true
    quantity?: true
    statusCode?: true
  }

  export type ProductOnOrderSumAggregateInputType = {
    id?: true
    productId?: true
    orderId?: true
    quantity?: true
    statusCode?: true
  }

  export type ProductOnOrderMinAggregateInputType = {
    id?: true
    productId?: true
    orderId?: true
    quantity?: true
    statusCode?: true
  }

  export type ProductOnOrderMaxAggregateInputType = {
    id?: true
    productId?: true
    orderId?: true
    quantity?: true
    statusCode?: true
  }

  export type ProductOnOrderCountAggregateInputType = {
    id?: true
    productId?: true
    orderId?: true
    quantity?: true
    statusCode?: true
    _all?: true
  }

  export type ProductOnOrderAggregateArgs = {
    /**
     * Filter which ProductOnOrder to aggregate.
     */
    where?: ProductOnOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOnOrders to fetch.
     */
    orderBy?: Enumerable<ProductOnOrderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductOnOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOnOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOnOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductOnOrders
    **/
    _count?: true | ProductOnOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductOnOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductOnOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductOnOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductOnOrderMaxAggregateInputType
  }

  export type GetProductOnOrderAggregateType<T extends ProductOnOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateProductOnOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductOnOrder[P]>
      : GetScalarType<T[P], AggregateProductOnOrder[P]>
  }




  export type ProductOnOrderGroupByArgs = {
    where?: ProductOnOrderWhereInput
    orderBy?: Enumerable<ProductOnOrderOrderByWithAggregationInput>
    by: ProductOnOrderScalarFieldEnum[]
    having?: ProductOnOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductOnOrderCountAggregateInputType | true
    _avg?: ProductOnOrderAvgAggregateInputType
    _sum?: ProductOnOrderSumAggregateInputType
    _min?: ProductOnOrderMinAggregateInputType
    _max?: ProductOnOrderMaxAggregateInputType
  }


  export type ProductOnOrderGroupByOutputType = {
    id: number
    productId: number
    orderId: number
    quantity: number
    statusCode: number
    _count: ProductOnOrderCountAggregateOutputType | null
    _avg: ProductOnOrderAvgAggregateOutputType | null
    _sum: ProductOnOrderSumAggregateOutputType | null
    _min: ProductOnOrderMinAggregateOutputType | null
    _max: ProductOnOrderMaxAggregateOutputType | null
  }

  type GetProductOnOrderGroupByPayload<T extends ProductOnOrderGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductOnOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductOnOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductOnOrderGroupByOutputType[P]>
            : GetScalarType<T[P], ProductOnOrderGroupByOutputType[P]>
        }
      >
    >


  export type ProductOnOrderSelect = {
    id?: boolean
    productId?: boolean
    product?: boolean | ProductArgs
    orderId?: boolean
    order?: boolean | OrderArgs
    quantity?: boolean
    statusCode?: boolean
  }


  export type ProductOnOrderInclude = {
    product?: boolean | ProductArgs
    order?: boolean | OrderArgs
  }

  export type ProductOnOrderGetPayload<S extends boolean | null | undefined | ProductOnOrderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductOnOrder :
    S extends undefined ? never :
    S extends { include: any } & (ProductOnOrderArgs | ProductOnOrderFindManyArgs)
    ? ProductOnOrder  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'product' ? ProductGetPayload<S['include'][P]> :
        P extends 'order' ? OrderGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductOnOrderArgs | ProductOnOrderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'product' ? ProductGetPayload<S['select'][P]> :
        P extends 'order' ? OrderGetPayload<S['select'][P]> :  P extends keyof ProductOnOrder ? ProductOnOrder[P] : never
  } 
      : ProductOnOrder


  type ProductOnOrderCountArgs = 
    Omit<ProductOnOrderFindManyArgs, 'select' | 'include'> & {
      select?: ProductOnOrderCountAggregateInputType | true
    }

  export interface ProductOnOrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProductOnOrder that matches the filter.
     * @param {ProductOnOrderFindUniqueArgs} args - Arguments to find a ProductOnOrder
     * @example
     * // Get one ProductOnOrder
     * const productOnOrder = await prisma.productOnOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductOnOrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductOnOrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductOnOrder'> extends True ? Prisma__ProductOnOrderClient<ProductOnOrderGetPayload<T>> : Prisma__ProductOnOrderClient<ProductOnOrderGetPayload<T> | null, null>

    /**
     * Find one ProductOnOrder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductOnOrderFindUniqueOrThrowArgs} args - Arguments to find a ProductOnOrder
     * @example
     * // Get one ProductOnOrder
     * const productOnOrder = await prisma.productOnOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductOnOrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductOnOrderFindUniqueOrThrowArgs>
    ): Prisma__ProductOnOrderClient<ProductOnOrderGetPayload<T>>

    /**
     * Find the first ProductOnOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOnOrderFindFirstArgs} args - Arguments to find a ProductOnOrder
     * @example
     * // Get one ProductOnOrder
     * const productOnOrder = await prisma.productOnOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductOnOrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductOnOrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductOnOrder'> extends True ? Prisma__ProductOnOrderClient<ProductOnOrderGetPayload<T>> : Prisma__ProductOnOrderClient<ProductOnOrderGetPayload<T> | null, null>

    /**
     * Find the first ProductOnOrder that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOnOrderFindFirstOrThrowArgs} args - Arguments to find a ProductOnOrder
     * @example
     * // Get one ProductOnOrder
     * const productOnOrder = await prisma.productOnOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductOnOrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductOnOrderFindFirstOrThrowArgs>
    ): Prisma__ProductOnOrderClient<ProductOnOrderGetPayload<T>>

    /**
     * Find zero or more ProductOnOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOnOrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductOnOrders
     * const productOnOrders = await prisma.productOnOrder.findMany()
     * 
     * // Get first 10 ProductOnOrders
     * const productOnOrders = await prisma.productOnOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productOnOrderWithIdOnly = await prisma.productOnOrder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductOnOrderFindManyArgs>(
      args?: SelectSubset<T, ProductOnOrderFindManyArgs>
    ): PrismaPromise<Array<ProductOnOrderGetPayload<T>>>

    /**
     * Create a ProductOnOrder.
     * @param {ProductOnOrderCreateArgs} args - Arguments to create a ProductOnOrder.
     * @example
     * // Create one ProductOnOrder
     * const ProductOnOrder = await prisma.productOnOrder.create({
     *   data: {
     *     // ... data to create a ProductOnOrder
     *   }
     * })
     * 
    **/
    create<T extends ProductOnOrderCreateArgs>(
      args: SelectSubset<T, ProductOnOrderCreateArgs>
    ): Prisma__ProductOnOrderClient<ProductOnOrderGetPayload<T>>

    /**
     * Create many ProductOnOrders.
     *     @param {ProductOnOrderCreateManyArgs} args - Arguments to create many ProductOnOrders.
     *     @example
     *     // Create many ProductOnOrders
     *     const productOnOrder = await prisma.productOnOrder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductOnOrderCreateManyArgs>(
      args?: SelectSubset<T, ProductOnOrderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductOnOrder.
     * @param {ProductOnOrderDeleteArgs} args - Arguments to delete one ProductOnOrder.
     * @example
     * // Delete one ProductOnOrder
     * const ProductOnOrder = await prisma.productOnOrder.delete({
     *   where: {
     *     // ... filter to delete one ProductOnOrder
     *   }
     * })
     * 
    **/
    delete<T extends ProductOnOrderDeleteArgs>(
      args: SelectSubset<T, ProductOnOrderDeleteArgs>
    ): Prisma__ProductOnOrderClient<ProductOnOrderGetPayload<T>>

    /**
     * Update one ProductOnOrder.
     * @param {ProductOnOrderUpdateArgs} args - Arguments to update one ProductOnOrder.
     * @example
     * // Update one ProductOnOrder
     * const productOnOrder = await prisma.productOnOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductOnOrderUpdateArgs>(
      args: SelectSubset<T, ProductOnOrderUpdateArgs>
    ): Prisma__ProductOnOrderClient<ProductOnOrderGetPayload<T>>

    /**
     * Delete zero or more ProductOnOrders.
     * @param {ProductOnOrderDeleteManyArgs} args - Arguments to filter ProductOnOrders to delete.
     * @example
     * // Delete a few ProductOnOrders
     * const { count } = await prisma.productOnOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductOnOrderDeleteManyArgs>(
      args?: SelectSubset<T, ProductOnOrderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductOnOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOnOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductOnOrders
     * const productOnOrder = await prisma.productOnOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductOnOrderUpdateManyArgs>(
      args: SelectSubset<T, ProductOnOrderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductOnOrder.
     * @param {ProductOnOrderUpsertArgs} args - Arguments to update or create a ProductOnOrder.
     * @example
     * // Update or create a ProductOnOrder
     * const productOnOrder = await prisma.productOnOrder.upsert({
     *   create: {
     *     // ... data to create a ProductOnOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductOnOrder we want to update
     *   }
     * })
    **/
    upsert<T extends ProductOnOrderUpsertArgs>(
      args: SelectSubset<T, ProductOnOrderUpsertArgs>
    ): Prisma__ProductOnOrderClient<ProductOnOrderGetPayload<T>>

    /**
     * Count the number of ProductOnOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOnOrderCountArgs} args - Arguments to filter ProductOnOrders to count.
     * @example
     * // Count the number of ProductOnOrders
     * const count = await prisma.productOnOrder.count({
     *   where: {
     *     // ... the filter for the ProductOnOrders we want to count
     *   }
     * })
    **/
    count<T extends ProductOnOrderCountArgs>(
      args?: Subset<T, ProductOnOrderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductOnOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductOnOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOnOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductOnOrderAggregateArgs>(args: Subset<T, ProductOnOrderAggregateArgs>): PrismaPromise<GetProductOnOrderAggregateType<T>>

    /**
     * Group by ProductOnOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOnOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductOnOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductOnOrderGroupByArgs['orderBy'] }
        : { orderBy?: ProductOnOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductOnOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductOnOrderGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductOnOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductOnOrderClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs= {}>(args?: Subset<T, ProductArgs>): Prisma__ProductClient<ProductGetPayload<T> | Null>;

    order<T extends OrderArgs= {}>(args?: Subset<T, OrderArgs>): Prisma__OrderClient<OrderGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductOnOrder base type for findUnique actions
   */
  export type ProductOnOrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProductOnOrder
     */
    select?: ProductOnOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOnOrderInclude | null
    /**
     * Filter, which ProductOnOrder to fetch.
     */
    where: ProductOnOrderWhereUniqueInput
  }

  /**
   * ProductOnOrder findUnique
   */
  export interface ProductOnOrderFindUniqueArgs extends ProductOnOrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductOnOrder findUniqueOrThrow
   */
  export type ProductOnOrderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductOnOrder
     */
    select?: ProductOnOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOnOrderInclude | null
    /**
     * Filter, which ProductOnOrder to fetch.
     */
    where: ProductOnOrderWhereUniqueInput
  }


  /**
   * ProductOnOrder base type for findFirst actions
   */
  export type ProductOnOrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProductOnOrder
     */
    select?: ProductOnOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOnOrderInclude | null
    /**
     * Filter, which ProductOnOrder to fetch.
     */
    where?: ProductOnOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOnOrders to fetch.
     */
    orderBy?: Enumerable<ProductOnOrderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductOnOrders.
     */
    cursor?: ProductOnOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOnOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOnOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductOnOrders.
     */
    distinct?: Enumerable<ProductOnOrderScalarFieldEnum>
  }

  /**
   * ProductOnOrder findFirst
   */
  export interface ProductOnOrderFindFirstArgs extends ProductOnOrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductOnOrder findFirstOrThrow
   */
  export type ProductOnOrderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductOnOrder
     */
    select?: ProductOnOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOnOrderInclude | null
    /**
     * Filter, which ProductOnOrder to fetch.
     */
    where?: ProductOnOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOnOrders to fetch.
     */
    orderBy?: Enumerable<ProductOnOrderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductOnOrders.
     */
    cursor?: ProductOnOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOnOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOnOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductOnOrders.
     */
    distinct?: Enumerable<ProductOnOrderScalarFieldEnum>
  }


  /**
   * ProductOnOrder findMany
   */
  export type ProductOnOrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductOnOrder
     */
    select?: ProductOnOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOnOrderInclude | null
    /**
     * Filter, which ProductOnOrders to fetch.
     */
    where?: ProductOnOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOnOrders to fetch.
     */
    orderBy?: Enumerable<ProductOnOrderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductOnOrders.
     */
    cursor?: ProductOnOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOnOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOnOrders.
     */
    skip?: number
    distinct?: Enumerable<ProductOnOrderScalarFieldEnum>
  }


  /**
   * ProductOnOrder create
   */
  export type ProductOnOrderCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductOnOrder
     */
    select?: ProductOnOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOnOrderInclude | null
    /**
     * The data needed to create a ProductOnOrder.
     */
    data: XOR<ProductOnOrderCreateInput, ProductOnOrderUncheckedCreateInput>
  }


  /**
   * ProductOnOrder createMany
   */
  export type ProductOnOrderCreateManyArgs = {
    /**
     * The data used to create many ProductOnOrders.
     */
    data: Enumerable<ProductOnOrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductOnOrder update
   */
  export type ProductOnOrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductOnOrder
     */
    select?: ProductOnOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOnOrderInclude | null
    /**
     * The data needed to update a ProductOnOrder.
     */
    data: XOR<ProductOnOrderUpdateInput, ProductOnOrderUncheckedUpdateInput>
    /**
     * Choose, which ProductOnOrder to update.
     */
    where: ProductOnOrderWhereUniqueInput
  }


  /**
   * ProductOnOrder updateMany
   */
  export type ProductOnOrderUpdateManyArgs = {
    /**
     * The data used to update ProductOnOrders.
     */
    data: XOR<ProductOnOrderUpdateManyMutationInput, ProductOnOrderUncheckedUpdateManyInput>
    /**
     * Filter which ProductOnOrders to update
     */
    where?: ProductOnOrderWhereInput
  }


  /**
   * ProductOnOrder upsert
   */
  export type ProductOnOrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductOnOrder
     */
    select?: ProductOnOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOnOrderInclude | null
    /**
     * The filter to search for the ProductOnOrder to update in case it exists.
     */
    where: ProductOnOrderWhereUniqueInput
    /**
     * In case the ProductOnOrder found by the `where` argument doesn't exist, create a new ProductOnOrder with this data.
     */
    create: XOR<ProductOnOrderCreateInput, ProductOnOrderUncheckedCreateInput>
    /**
     * In case the ProductOnOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductOnOrderUpdateInput, ProductOnOrderUncheckedUpdateInput>
  }


  /**
   * ProductOnOrder delete
   */
  export type ProductOnOrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductOnOrder
     */
    select?: ProductOnOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOnOrderInclude | null
    /**
     * Filter which ProductOnOrder to delete.
     */
    where: ProductOnOrderWhereUniqueInput
  }


  /**
   * ProductOnOrder deleteMany
   */
  export type ProductOnOrderDeleteManyArgs = {
    /**
     * Filter which ProductOnOrders to delete
     */
    where?: ProductOnOrderWhereInput
  }


  /**
   * ProductOnOrder without action
   */
  export type ProductOnOrderArgs = {
    /**
     * Select specific fields to fetch from the ProductOnOrder
     */
    select?: ProductOnOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOnOrderInclude | null
  }



  /**
   * Model Review
   */


  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    clientId: number | null
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    id: number | null
    productId: number | null
    clientId: number | null
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: number | null
    productId: number | null
    clientId: number | null
    createdAt: Date | null
    lastEditTime: Date | null
    title: string | null
    text: string | null
    rating: number | null
    retailerAnswer: string | null
    answerCreatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    clientId: number | null
    createdAt: Date | null
    lastEditTime: Date | null
    title: string | null
    text: string | null
    rating: number | null
    retailerAnswer: string | null
    answerCreatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    productId: number
    clientId: number
    createdAt: number
    lastEditTime: number
    title: number
    text: number
    rating: number
    retailerAnswer: number
    answerCreatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    productId?: true
    clientId?: true
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    productId?: true
    clientId?: true
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    productId?: true
    clientId?: true
    createdAt?: true
    lastEditTime?: true
    title?: true
    text?: true
    rating?: true
    retailerAnswer?: true
    answerCreatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    productId?: true
    clientId?: true
    createdAt?: true
    lastEditTime?: true
    title?: true
    text?: true
    rating?: true
    retailerAnswer?: true
    answerCreatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    productId?: true
    clientId?: true
    createdAt?: true
    lastEditTime?: true
    title?: true
    text?: true
    rating?: true
    retailerAnswer?: true
    answerCreatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: Enumerable<ReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs = {
    where?: ReviewWhereInput
    orderBy?: Enumerable<ReviewOrderByWithAggregationInput>
    by: ReviewScalarFieldEnum[]
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }


  export type ReviewGroupByOutputType = {
    id: number
    productId: number
    clientId: number
    createdAt: Date
    lastEditTime: Date
    title: string
    text: string
    rating: number
    retailerAnswer: string | null
    answerCreatedAt: Date | null
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect = {
    id?: boolean
    productId?: boolean
    product?: boolean | ProductArgs
    clientId?: boolean
    client?: boolean | ClientArgs
    createdAt?: boolean
    lastEditTime?: boolean
    title?: boolean
    text?: boolean
    rating?: boolean
    retailerAnswer?: boolean
    answerCreatedAt?: boolean
  }


  export type ReviewInclude = {
    product?: boolean | ProductArgs
    client?: boolean | ClientArgs
  }

  export type ReviewGetPayload<S extends boolean | null | undefined | ReviewArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Review :
    S extends undefined ? never :
    S extends { include: any } & (ReviewArgs | ReviewFindManyArgs)
    ? Review  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'product' ? ProductGetPayload<S['include'][P]> :
        P extends 'client' ? ClientGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ReviewArgs | ReviewFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'product' ? ProductGetPayload<S['select'][P]> :
        P extends 'client' ? ClientGetPayload<S['select'][P]> :  P extends keyof Review ? Review[P] : never
  } 
      : Review


  type ReviewCountArgs = 
    Omit<ReviewFindManyArgs, 'select' | 'include'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Review'> extends True ? Prisma__ReviewClient<ReviewGetPayload<T>> : Prisma__ReviewClient<ReviewGetPayload<T> | null, null>

    /**
     * Find one Review that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReviewFindUniqueOrThrowArgs>
    ): Prisma__ReviewClient<ReviewGetPayload<T>>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Review'> extends True ? Prisma__ReviewClient<ReviewGetPayload<T>> : Prisma__ReviewClient<ReviewGetPayload<T> | null, null>

    /**
     * Find the first Review that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReviewFindFirstOrThrowArgs>
    ): Prisma__ReviewClient<ReviewGetPayload<T>>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReviewFindManyArgs>(
      args?: SelectSubset<T, ReviewFindManyArgs>
    ): PrismaPromise<Array<ReviewGetPayload<T>>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
    **/
    create<T extends ReviewCreateArgs>(
      args: SelectSubset<T, ReviewCreateArgs>
    ): Prisma__ReviewClient<ReviewGetPayload<T>>

    /**
     * Create many Reviews.
     *     @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     *     @example
     *     // Create many Reviews
     *     const review = await prisma.review.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReviewCreateManyArgs>(
      args?: SelectSubset<T, ReviewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
    **/
    delete<T extends ReviewDeleteArgs>(
      args: SelectSubset<T, ReviewDeleteArgs>
    ): Prisma__ReviewClient<ReviewGetPayload<T>>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReviewUpdateArgs>(
      args: SelectSubset<T, ReviewUpdateArgs>
    ): Prisma__ReviewClient<ReviewGetPayload<T>>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReviewDeleteManyArgs>(
      args?: SelectSubset<T, ReviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReviewUpdateManyArgs>(
      args: SelectSubset<T, ReviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
    **/
    upsert<T extends ReviewUpsertArgs>(
      args: SelectSubset<T, ReviewUpsertArgs>
    ): Prisma__ReviewClient<ReviewGetPayload<T>>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReviewClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs= {}>(args?: Subset<T, ProductArgs>): Prisma__ProductClient<ProductGetPayload<T> | Null>;

    client<T extends ClientArgs= {}>(args?: Subset<T, ClientArgs>): Prisma__ClientClient<ClientGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Review base type for findUnique actions
   */
  export type ReviewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUnique
   */
  export interface ReviewFindUniqueArgs extends ReviewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review base type for findFirst actions
   */
  export type ReviewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: Enumerable<ReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }

  /**
   * Review findFirst
   */
  export interface ReviewFindFirstArgs extends ReviewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: Enumerable<ReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * Review findMany
   */
  export type ReviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: Enumerable<ReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * Review create
   */
  export type ReviewCreateArgs = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }


  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs = {
    /**
     * The data used to create many Reviews.
     */
    data: Enumerable<ReviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Review update
   */
  export type ReviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }


  /**
   * Review upsert
   */
  export type ReviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }


  /**
   * Review delete
   */
  export type ReviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }


  /**
   * Review without action
   */
  export type ReviewArgs = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    price: number | null
    retailerId: number | null
    clicks: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    amount: number | null
    price: number | null
    retailerId: number | null
    clicks: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    title: string | null
    amount: number | null
    price: number | null
    brand: string | null
    country: string | null
    expires: string | null
    wayToUse: string | null
    contain: string | null
    description: string | null
    storage: string | null
    note: string | null
    visible: boolean | null
    retailerId: number | null
    clicks: number | null
    createdAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    title: string | null
    amount: number | null
    price: number | null
    brand: string | null
    country: string | null
    expires: string | null
    wayToUse: string | null
    contain: string | null
    description: string | null
    storage: string | null
    note: string | null
    visible: boolean | null
    retailerId: number | null
    clicks: number | null
    createdAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    title: number
    amount: number
    price: number
    brand: number
    country: number
    expires: number
    wayToUse: number
    contain: number
    description: number
    storage: number
    note: number
    visible: number
    retailerId: number
    clicks: number
    createdAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    amount?: true
    price?: true
    retailerId?: true
    clicks?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    amount?: true
    price?: true
    retailerId?: true
    clicks?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    price?: true
    brand?: true
    country?: true
    expires?: true
    wayToUse?: true
    contain?: true
    description?: true
    storage?: true
    note?: true
    visible?: true
    retailerId?: true
    clicks?: true
    createdAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    price?: true
    brand?: true
    country?: true
    expires?: true
    wayToUse?: true
    contain?: true
    description?: true
    storage?: true
    note?: true
    visible?: true
    retailerId?: true
    clicks?: true
    createdAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    price?: true
    brand?: true
    country?: true
    expires?: true
    wayToUse?: true
    contain?: true
    description?: true
    storage?: true
    note?: true
    visible?: true
    retailerId?: true
    clicks?: true
    createdAt?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: ProductScalarFieldEnum[]
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: number
    title: string
    amount: number
    price: number
    brand: string
    country: string | null
    expires: string | null
    wayToUse: string | null
    contain: string | null
    description: string
    storage: string
    note: string | null
    visible: boolean
    retailerId: number
    clicks: number
    createdAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    title?: boolean
    amount?: boolean
    price?: boolean
    brand?: boolean
    country?: boolean
    expires?: boolean
    wayToUse?: boolean
    contain?: boolean
    description?: boolean
    storage?: boolean
    note?: boolean
    visible?: boolean
    retailerId?: boolean
    retailer?: boolean | RetailerArgs
    clicks?: boolean
    createdAt?: boolean
    categories?: boolean | Product$categoriesArgs
    images?: boolean | Product$imagesArgs
    reviews?: boolean | Product$reviewsArgs
    orders?: boolean | Product$ordersArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }


  export type ProductInclude = {
    retailer?: boolean | RetailerArgs
    categories?: boolean | Product$categoriesArgs
    images?: boolean | Product$imagesArgs
    reviews?: boolean | Product$reviewsArgs
    orders?: boolean | Product$ordersArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductGetPayload<S extends boolean | null | undefined | ProductArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Product :
    S extends undefined ? never :
    S extends { include: any } & (ProductArgs | ProductFindManyArgs)
    ? Product  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'retailer' ? RetailerGetPayload<S['include'][P]> :
        P extends 'categories' ? Array < CategoryGetPayload<S['include'][P]>>  :
        P extends 'images' ? Array < ProductImageGetPayload<S['include'][P]>>  :
        P extends 'reviews' ? Array < ReviewGetPayload<S['include'][P]>>  :
        P extends 'orders' ? Array < ProductOnOrderGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductArgs | ProductFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'retailer' ? RetailerGetPayload<S['select'][P]> :
        P extends 'categories' ? Array < CategoryGetPayload<S['select'][P]>>  :
        P extends 'images' ? Array < ProductImageGetPayload<S['select'][P]>>  :
        P extends 'reviews' ? Array < ReviewGetPayload<S['select'][P]>>  :
        P extends 'orders' ? Array < ProductOnOrderGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Product ? Product[P] : never
  } 
      : Product


  type ProductCountArgs = 
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? Prisma__ProductClient<ProductGetPayload<T>> : Prisma__ProductClient<ProductGetPayload<T> | null, null>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? Prisma__ProductClient<ProductGetPayload<T>> : Prisma__ProductClient<ProductGetPayload<T> | null, null>

    /**
     * Find the first Product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): PrismaPromise<Array<ProductGetPayload<T>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    retailer<T extends RetailerArgs= {}>(args?: Subset<T, RetailerArgs>): Prisma__RetailerClient<RetailerGetPayload<T> | Null>;

    categories<T extends Product$categoriesArgs= {}>(args?: Subset<T, Product$categoriesArgs>): PrismaPromise<Array<CategoryGetPayload<T>>| Null>;

    images<T extends Product$imagesArgs= {}>(args?: Subset<T, Product$imagesArgs>): PrismaPromise<Array<ProductImageGetPayload<T>>| Null>;

    reviews<T extends Product$reviewsArgs= {}>(args?: Subset<T, Product$reviewsArgs>): PrismaPromise<Array<ReviewGetPayload<T>>| Null>;

    orders<T extends Product$ordersArgs= {}>(args?: Subset<T, Product$ordersArgs>): PrismaPromise<Array<ProductOnOrderGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Product base type for findUnique actions
   */
  export type ProductFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUnique
   */
  export interface ProductFindUniqueArgs extends ProductFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product base type for findFirst actions
   */
  export type ProductFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }

  /**
   * Product findFirst
   */
  export interface ProductFindFirstArgs extends ProductFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    /**
     * The data used to create many Products.
     */
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }


  /**
   * Product.categories
   */
  export type Product$categoriesArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithRelationAndSearchRelevanceInput>
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Product.images
   */
  export type Product$imagesArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude | null
    where?: ProductImageWhereInput
    orderBy?: Enumerable<ProductImageOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ProductImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductImageScalarFieldEnum>
  }


  /**
   * Product.reviews
   */
  export type Product$reviewsArgs = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude | null
    where?: ReviewWhereInput
    orderBy?: Enumerable<ReviewOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * Product.orders
   */
  export type Product$ordersArgs = {
    /**
     * Select specific fields to fetch from the ProductOnOrder
     */
    select?: ProductOnOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOnOrderInclude | null
    where?: ProductOnOrderWhereInput
    orderBy?: Enumerable<ProductOnOrderOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ProductOnOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductOnOrderScalarFieldEnum>
  }


  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
  }



  /**
   * Model ProductImage
   */


  export type AggregateProductImage = {
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  export type ProductImageAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductImageSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductImageMinAggregateOutputType = {
    id: number | null
    path: string | null
    alt: string | null
    productId: number | null
  }

  export type ProductImageMaxAggregateOutputType = {
    id: number | null
    path: string | null
    alt: string | null
    productId: number | null
  }

  export type ProductImageCountAggregateOutputType = {
    id: number
    path: number
    alt: number
    productId: number
    _all: number
  }


  export type ProductImageAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductImageSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductImageMinAggregateInputType = {
    id?: true
    path?: true
    alt?: true
    productId?: true
  }

  export type ProductImageMaxAggregateInputType = {
    id?: true
    path?: true
    alt?: true
    productId?: true
  }

  export type ProductImageCountAggregateInputType = {
    id?: true
    path?: true
    alt?: true
    productId?: true
    _all?: true
  }

  export type ProductImageAggregateArgs = {
    /**
     * Filter which ProductImage to aggregate.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: Enumerable<ProductImageOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductImages
    **/
    _count?: true | ProductImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductImageMaxAggregateInputType
  }

  export type GetProductImageAggregateType<T extends ProductImageAggregateArgs> = {
        [P in keyof T & keyof AggregateProductImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImage[P]>
      : GetScalarType<T[P], AggregateProductImage[P]>
  }




  export type ProductImageGroupByArgs = {
    where?: ProductImageWhereInput
    orderBy?: Enumerable<ProductImageOrderByWithAggregationInput>
    by: ProductImageScalarFieldEnum[]
    having?: ProductImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductImageCountAggregateInputType | true
    _avg?: ProductImageAvgAggregateInputType
    _sum?: ProductImageSumAggregateInputType
    _min?: ProductImageMinAggregateInputType
    _max?: ProductImageMaxAggregateInputType
  }


  export type ProductImageGroupByOutputType = {
    id: number
    path: string
    alt: string
    productId: number
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  type GetProductImageGroupByPayload<T extends ProductImageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
            : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
        }
      >
    >


  export type ProductImageSelect = {
    id?: boolean
    path?: boolean
    alt?: boolean
    productId?: boolean
    product?: boolean | ProductArgs
  }


  export type ProductImageInclude = {
    product?: boolean | ProductArgs
  }

  export type ProductImageGetPayload<S extends boolean | null | undefined | ProductImageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductImage :
    S extends undefined ? never :
    S extends { include: any } & (ProductImageArgs | ProductImageFindManyArgs)
    ? ProductImage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'product' ? ProductGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductImageArgs | ProductImageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'product' ? ProductGetPayload<S['select'][P]> :  P extends keyof ProductImage ? ProductImage[P] : never
  } 
      : ProductImage


  type ProductImageCountArgs = 
    Omit<ProductImageFindManyArgs, 'select' | 'include'> & {
      select?: ProductImageCountAggregateInputType | true
    }

  export interface ProductImageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProductImage that matches the filter.
     * @param {ProductImageFindUniqueArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductImage'> extends True ? Prisma__ProductImageClient<ProductImageGetPayload<T>> : Prisma__ProductImageClient<ProductImageGetPayload<T> | null, null>

    /**
     * Find one ProductImage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductImageFindUniqueOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductImageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductImageFindUniqueOrThrowArgs>
    ): Prisma__ProductImageClient<ProductImageGetPayload<T>>

    /**
     * Find the first ProductImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductImage'> extends True ? Prisma__ProductImageClient<ProductImageGetPayload<T>> : Prisma__ProductImageClient<ProductImageGetPayload<T> | null, null>

    /**
     * Find the first ProductImage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductImageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductImageFindFirstOrThrowArgs>
    ): Prisma__ProductImageClient<ProductImageGetPayload<T>>

    /**
     * Find zero or more ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImages
     * const productImages = await prisma.productImage.findMany()
     * 
     * // Get first 10 ProductImages
     * const productImages = await prisma.productImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productImageWithIdOnly = await prisma.productImage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductImageFindManyArgs>(
      args?: SelectSubset<T, ProductImageFindManyArgs>
    ): PrismaPromise<Array<ProductImageGetPayload<T>>>

    /**
     * Create a ProductImage.
     * @param {ProductImageCreateArgs} args - Arguments to create a ProductImage.
     * @example
     * // Create one ProductImage
     * const ProductImage = await prisma.productImage.create({
     *   data: {
     *     // ... data to create a ProductImage
     *   }
     * })
     * 
    **/
    create<T extends ProductImageCreateArgs>(
      args: SelectSubset<T, ProductImageCreateArgs>
    ): Prisma__ProductImageClient<ProductImageGetPayload<T>>

    /**
     * Create many ProductImages.
     *     @param {ProductImageCreateManyArgs} args - Arguments to create many ProductImages.
     *     @example
     *     // Create many ProductImages
     *     const productImage = await prisma.productImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductImageCreateManyArgs>(
      args?: SelectSubset<T, ProductImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductImage.
     * @param {ProductImageDeleteArgs} args - Arguments to delete one ProductImage.
     * @example
     * // Delete one ProductImage
     * const ProductImage = await prisma.productImage.delete({
     *   where: {
     *     // ... filter to delete one ProductImage
     *   }
     * })
     * 
    **/
    delete<T extends ProductImageDeleteArgs>(
      args: SelectSubset<T, ProductImageDeleteArgs>
    ): Prisma__ProductImageClient<ProductImageGetPayload<T>>

    /**
     * Update one ProductImage.
     * @param {ProductImageUpdateArgs} args - Arguments to update one ProductImage.
     * @example
     * // Update one ProductImage
     * const productImage = await prisma.productImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductImageUpdateArgs>(
      args: SelectSubset<T, ProductImageUpdateArgs>
    ): Prisma__ProductImageClient<ProductImageGetPayload<T>>

    /**
     * Delete zero or more ProductImages.
     * @param {ProductImageDeleteManyArgs} args - Arguments to filter ProductImages to delete.
     * @example
     * // Delete a few ProductImages
     * const { count } = await prisma.productImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductImageDeleteManyArgs>(
      args?: SelectSubset<T, ProductImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductImageUpdateManyArgs>(
      args: SelectSubset<T, ProductImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductImage.
     * @param {ProductImageUpsertArgs} args - Arguments to update or create a ProductImage.
     * @example
     * // Update or create a ProductImage
     * const productImage = await prisma.productImage.upsert({
     *   create: {
     *     // ... data to create a ProductImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductImage we want to update
     *   }
     * })
    **/
    upsert<T extends ProductImageUpsertArgs>(
      args: SelectSubset<T, ProductImageUpsertArgs>
    ): Prisma__ProductImageClient<ProductImageGetPayload<T>>

    /**
     * Count the number of ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageCountArgs} args - Arguments to filter ProductImages to count.
     * @example
     * // Count the number of ProductImages
     * const count = await prisma.productImage.count({
     *   where: {
     *     // ... the filter for the ProductImages we want to count
     *   }
     * })
    **/
    count<T extends ProductImageCountArgs>(
      args?: Subset<T, ProductImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductImageAggregateArgs>(args: Subset<T, ProductImageAggregateArgs>): PrismaPromise<GetProductImageAggregateType<T>>

    /**
     * Group by ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImageGroupByArgs['orderBy'] }
        : { orderBy?: ProductImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductImageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductImageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs= {}>(args?: Subset<T, ProductArgs>): Prisma__ProductClient<ProductGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductImage base type for findUnique actions
   */
  export type ProductImageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findUnique
   */
  export interface ProductImageFindUniqueArgs extends ProductImageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductImage findUniqueOrThrow
   */
  export type ProductImageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }


  /**
   * ProductImage base type for findFirst actions
   */
  export type ProductImageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: Enumerable<ProductImageOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: Enumerable<ProductImageScalarFieldEnum>
  }

  /**
   * ProductImage findFirst
   */
  export interface ProductImageFindFirstArgs extends ProductImageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductImage findFirstOrThrow
   */
  export type ProductImageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: Enumerable<ProductImageOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: Enumerable<ProductImageScalarFieldEnum>
  }


  /**
   * ProductImage findMany
   */
  export type ProductImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: Enumerable<ProductImageOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    distinct?: Enumerable<ProductImageScalarFieldEnum>
  }


  /**
   * ProductImage create
   */
  export type ProductImageCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude | null
    /**
     * The data needed to create a ProductImage.
     */
    data: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
  }


  /**
   * ProductImage createMany
   */
  export type ProductImageCreateManyArgs = {
    /**
     * The data used to create many ProductImages.
     */
    data: Enumerable<ProductImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductImage update
   */
  export type ProductImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude | null
    /**
     * The data needed to update a ProductImage.
     */
    data: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
    /**
     * Choose, which ProductImage to update.
     */
    where: ProductImageWhereUniqueInput
  }


  /**
   * ProductImage updateMany
   */
  export type ProductImageUpdateManyArgs = {
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput
  }


  /**
   * ProductImage upsert
   */
  export type ProductImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude | null
    /**
     * The filter to search for the ProductImage to update in case it exists.
     */
    where: ProductImageWhereUniqueInput
    /**
     * In case the ProductImage found by the `where` argument doesn't exist, create a new ProductImage with this data.
     */
    create: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
    /**
     * In case the ProductImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
  }


  /**
   * ProductImage delete
   */
  export type ProductImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude | null
    /**
     * Filter which ProductImage to delete.
     */
    where: ProductImageWhereUniqueInput
  }


  /**
   * ProductImage deleteMany
   */
  export type ProductImageDeleteManyArgs = {
    /**
     * Filter which ProductImages to delete
     */
    where?: ProductImageWhereInput
  }


  /**
   * ProductImage without action
   */
  export type ProductImageArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude | null
  }



  /**
   * Model Category
   */


  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    keywords: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    keywords?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs = {
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithAggregationInput>
    by: CategoryScalarFieldEnum[]
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: number
    name: string
    keywords: string[]
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect = {
    id?: boolean
    name?: boolean
    keywords?: boolean
    products?: boolean | Category$productsArgs
    retailers?: boolean | Category$retailersArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }


  export type CategoryInclude = {
    products?: boolean | Category$productsArgs
    retailers?: boolean | Category$retailersArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }

  export type CategoryGetPayload<S extends boolean | null | undefined | CategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Category :
    S extends undefined ? never :
    S extends { include: any } & (CategoryArgs | CategoryFindManyArgs)
    ? Category  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'products' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'retailers' ? Array < RetailerGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CategoryArgs | CategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'products' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'retailers' ? Array < RetailerGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Category ? Category[P] : never
  } 
      : Category


  type CategoryCountArgs = 
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Category'> extends True ? Prisma__CategoryClient<CategoryGetPayload<T>> : Prisma__CategoryClient<CategoryGetPayload<T> | null, null>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindUniqueOrThrowArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Category'> extends True ? Prisma__CategoryClient<CategoryGetPayload<T>> : Prisma__CategoryClient<CategoryGetPayload<T> | null, null>

    /**
     * Find the first Category that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs>
    ): PrismaPromise<Array<CategoryGetPayload<T>>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends Category$productsArgs= {}>(args?: Subset<T, Category$productsArgs>): PrismaPromise<Array<ProductGetPayload<T>>| Null>;

    retailers<T extends Category$retailersArgs= {}>(args?: Subset<T, Category$retailersArgs>): PrismaPromise<Array<RetailerGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Category base type for findUnique actions
   */
  export type CategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUnique
   */
  export interface CategoryFindUniqueArgs extends CategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category base type for findFirst actions
   */
  export type CategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }

  /**
   * Category findFirst
   */
  export interface CategoryFindFirstArgs extends CategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs = {
    /**
     * The data used to create many Categories.
     */
    data: Enumerable<CategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }


  /**
   * Category.products
   */
  export type Category$productsArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Category.retailers
   */
  export type Category$retailersArgs = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RetailerInclude | null
    where?: RetailerWhereInput
    orderBy?: Enumerable<RetailerOrderByWithRelationAndSearchRelevanceInput>
    cursor?: RetailerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RetailerScalarFieldEnum>
  }


  /**
   * Category without action
   */
  export type CategoryArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
  }



  /**
   * Model Retailer
   */


  export type AggregateRetailer = {
    _count: RetailerCountAggregateOutputType | null
    _avg: RetailerAvgAggregateOutputType | null
    _sum: RetailerSumAggregateOutputType | null
    _min: RetailerMinAggregateOutputType | null
    _max: RetailerMaxAggregateOutputType | null
  }

  export type RetailerAvgAggregateOutputType = {
    id: number | null
  }

  export type RetailerSumAggregateOutputType = {
    id: number | null
  }

  export type RetailerMinAggregateOutputType = {
    id: number | null
    email: string | null
    emailConfirmed: boolean | null
    photo: string | null
    name: string | null
    surname: string | null
    patrinymic: string | null
    phone: string | null
    companyName: string | null
    city: string | null
    confirmed: boolean | null
    password: string | null
  }

  export type RetailerMaxAggregateOutputType = {
    id: number | null
    email: string | null
    emailConfirmed: boolean | null
    photo: string | null
    name: string | null
    surname: string | null
    patrinymic: string | null
    phone: string | null
    companyName: string | null
    city: string | null
    confirmed: boolean | null
    password: string | null
  }

  export type RetailerCountAggregateOutputType = {
    id: number
    email: number
    emailConfirmed: number
    photo: number
    name: number
    surname: number
    patrinymic: number
    phone: number
    companyName: number
    city: number
    confirmed: number
    password: number
    _all: number
  }


  export type RetailerAvgAggregateInputType = {
    id?: true
  }

  export type RetailerSumAggregateInputType = {
    id?: true
  }

  export type RetailerMinAggregateInputType = {
    id?: true
    email?: true
    emailConfirmed?: true
    photo?: true
    name?: true
    surname?: true
    patrinymic?: true
    phone?: true
    companyName?: true
    city?: true
    confirmed?: true
    password?: true
  }

  export type RetailerMaxAggregateInputType = {
    id?: true
    email?: true
    emailConfirmed?: true
    photo?: true
    name?: true
    surname?: true
    patrinymic?: true
    phone?: true
    companyName?: true
    city?: true
    confirmed?: true
    password?: true
  }

  export type RetailerCountAggregateInputType = {
    id?: true
    email?: true
    emailConfirmed?: true
    photo?: true
    name?: true
    surname?: true
    patrinymic?: true
    phone?: true
    companyName?: true
    city?: true
    confirmed?: true
    password?: true
    _all?: true
  }

  export type RetailerAggregateArgs = {
    /**
     * Filter which Retailer to aggregate.
     */
    where?: RetailerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retailers to fetch.
     */
    orderBy?: Enumerable<RetailerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RetailerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retailers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retailers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Retailers
    **/
    _count?: true | RetailerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RetailerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RetailerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RetailerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RetailerMaxAggregateInputType
  }

  export type GetRetailerAggregateType<T extends RetailerAggregateArgs> = {
        [P in keyof T & keyof AggregateRetailer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRetailer[P]>
      : GetScalarType<T[P], AggregateRetailer[P]>
  }




  export type RetailerGroupByArgs = {
    where?: RetailerWhereInput
    orderBy?: Enumerable<RetailerOrderByWithAggregationInput>
    by: RetailerScalarFieldEnum[]
    having?: RetailerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RetailerCountAggregateInputType | true
    _avg?: RetailerAvgAggregateInputType
    _sum?: RetailerSumAggregateInputType
    _min?: RetailerMinAggregateInputType
    _max?: RetailerMaxAggregateInputType
  }


  export type RetailerGroupByOutputType = {
    id: number
    email: string
    emailConfirmed: boolean
    photo: string
    name: string
    surname: string
    patrinymic: string
    phone: string | null
    companyName: string
    city: string
    confirmed: boolean
    password: string
    _count: RetailerCountAggregateOutputType | null
    _avg: RetailerAvgAggregateOutputType | null
    _sum: RetailerSumAggregateOutputType | null
    _min: RetailerMinAggregateOutputType | null
    _max: RetailerMaxAggregateOutputType | null
  }

  type GetRetailerGroupByPayload<T extends RetailerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RetailerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RetailerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RetailerGroupByOutputType[P]>
            : GetScalarType<T[P], RetailerGroupByOutputType[P]>
        }
      >
    >


  export type RetailerSelect = {
    id?: boolean
    email?: boolean
    emailConfirmed?: boolean
    photo?: boolean
    name?: boolean
    surname?: boolean
    patrinymic?: boolean
    phone?: boolean
    companyName?: boolean
    city?: boolean
    confirmed?: boolean
    password?: boolean
    products?: boolean | Retailer$productsArgs
    categorys?: boolean | Retailer$categorysArgs
    _count?: boolean | RetailerCountOutputTypeArgs
  }


  export type RetailerInclude = {
    products?: boolean | Retailer$productsArgs
    categorys?: boolean | Retailer$categorysArgs
    _count?: boolean | RetailerCountOutputTypeArgs
  }

  export type RetailerGetPayload<S extends boolean | null | undefined | RetailerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Retailer :
    S extends undefined ? never :
    S extends { include: any } & (RetailerArgs | RetailerFindManyArgs)
    ? Retailer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'products' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'categorys' ? Array < CategoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? RetailerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RetailerArgs | RetailerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'products' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'categorys' ? Array < CategoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? RetailerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Retailer ? Retailer[P] : never
  } 
      : Retailer


  type RetailerCountArgs = 
    Omit<RetailerFindManyArgs, 'select' | 'include'> & {
      select?: RetailerCountAggregateInputType | true
    }

  export interface RetailerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Retailer that matches the filter.
     * @param {RetailerFindUniqueArgs} args - Arguments to find a Retailer
     * @example
     * // Get one Retailer
     * const retailer = await prisma.retailer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RetailerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RetailerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Retailer'> extends True ? Prisma__RetailerClient<RetailerGetPayload<T>> : Prisma__RetailerClient<RetailerGetPayload<T> | null, null>

    /**
     * Find one Retailer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RetailerFindUniqueOrThrowArgs} args - Arguments to find a Retailer
     * @example
     * // Get one Retailer
     * const retailer = await prisma.retailer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RetailerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RetailerFindUniqueOrThrowArgs>
    ): Prisma__RetailerClient<RetailerGetPayload<T>>

    /**
     * Find the first Retailer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetailerFindFirstArgs} args - Arguments to find a Retailer
     * @example
     * // Get one Retailer
     * const retailer = await prisma.retailer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RetailerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RetailerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Retailer'> extends True ? Prisma__RetailerClient<RetailerGetPayload<T>> : Prisma__RetailerClient<RetailerGetPayload<T> | null, null>

    /**
     * Find the first Retailer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetailerFindFirstOrThrowArgs} args - Arguments to find a Retailer
     * @example
     * // Get one Retailer
     * const retailer = await prisma.retailer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RetailerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RetailerFindFirstOrThrowArgs>
    ): Prisma__RetailerClient<RetailerGetPayload<T>>

    /**
     * Find zero or more Retailers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetailerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Retailers
     * const retailers = await prisma.retailer.findMany()
     * 
     * // Get first 10 Retailers
     * const retailers = await prisma.retailer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const retailerWithIdOnly = await prisma.retailer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RetailerFindManyArgs>(
      args?: SelectSubset<T, RetailerFindManyArgs>
    ): PrismaPromise<Array<RetailerGetPayload<T>>>

    /**
     * Create a Retailer.
     * @param {RetailerCreateArgs} args - Arguments to create a Retailer.
     * @example
     * // Create one Retailer
     * const Retailer = await prisma.retailer.create({
     *   data: {
     *     // ... data to create a Retailer
     *   }
     * })
     * 
    **/
    create<T extends RetailerCreateArgs>(
      args: SelectSubset<T, RetailerCreateArgs>
    ): Prisma__RetailerClient<RetailerGetPayload<T>>

    /**
     * Create many Retailers.
     *     @param {RetailerCreateManyArgs} args - Arguments to create many Retailers.
     *     @example
     *     // Create many Retailers
     *     const retailer = await prisma.retailer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RetailerCreateManyArgs>(
      args?: SelectSubset<T, RetailerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Retailer.
     * @param {RetailerDeleteArgs} args - Arguments to delete one Retailer.
     * @example
     * // Delete one Retailer
     * const Retailer = await prisma.retailer.delete({
     *   where: {
     *     // ... filter to delete one Retailer
     *   }
     * })
     * 
    **/
    delete<T extends RetailerDeleteArgs>(
      args: SelectSubset<T, RetailerDeleteArgs>
    ): Prisma__RetailerClient<RetailerGetPayload<T>>

    /**
     * Update one Retailer.
     * @param {RetailerUpdateArgs} args - Arguments to update one Retailer.
     * @example
     * // Update one Retailer
     * const retailer = await prisma.retailer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RetailerUpdateArgs>(
      args: SelectSubset<T, RetailerUpdateArgs>
    ): Prisma__RetailerClient<RetailerGetPayload<T>>

    /**
     * Delete zero or more Retailers.
     * @param {RetailerDeleteManyArgs} args - Arguments to filter Retailers to delete.
     * @example
     * // Delete a few Retailers
     * const { count } = await prisma.retailer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RetailerDeleteManyArgs>(
      args?: SelectSubset<T, RetailerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Retailers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetailerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Retailers
     * const retailer = await prisma.retailer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RetailerUpdateManyArgs>(
      args: SelectSubset<T, RetailerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Retailer.
     * @param {RetailerUpsertArgs} args - Arguments to update or create a Retailer.
     * @example
     * // Update or create a Retailer
     * const retailer = await prisma.retailer.upsert({
     *   create: {
     *     // ... data to create a Retailer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Retailer we want to update
     *   }
     * })
    **/
    upsert<T extends RetailerUpsertArgs>(
      args: SelectSubset<T, RetailerUpsertArgs>
    ): Prisma__RetailerClient<RetailerGetPayload<T>>

    /**
     * Count the number of Retailers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetailerCountArgs} args - Arguments to filter Retailers to count.
     * @example
     * // Count the number of Retailers
     * const count = await prisma.retailer.count({
     *   where: {
     *     // ... the filter for the Retailers we want to count
     *   }
     * })
    **/
    count<T extends RetailerCountArgs>(
      args?: Subset<T, RetailerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RetailerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Retailer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetailerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RetailerAggregateArgs>(args: Subset<T, RetailerAggregateArgs>): PrismaPromise<GetRetailerAggregateType<T>>

    /**
     * Group by Retailer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetailerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RetailerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RetailerGroupByArgs['orderBy'] }
        : { orderBy?: RetailerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RetailerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRetailerGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Retailer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RetailerClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends Retailer$productsArgs= {}>(args?: Subset<T, Retailer$productsArgs>): PrismaPromise<Array<ProductGetPayload<T>>| Null>;

    categorys<T extends Retailer$categorysArgs= {}>(args?: Subset<T, Retailer$categorysArgs>): PrismaPromise<Array<CategoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Retailer base type for findUnique actions
   */
  export type RetailerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RetailerInclude | null
    /**
     * Filter, which Retailer to fetch.
     */
    where: RetailerWhereUniqueInput
  }

  /**
   * Retailer findUnique
   */
  export interface RetailerFindUniqueArgs extends RetailerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Retailer findUniqueOrThrow
   */
  export type RetailerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RetailerInclude | null
    /**
     * Filter, which Retailer to fetch.
     */
    where: RetailerWhereUniqueInput
  }


  /**
   * Retailer base type for findFirst actions
   */
  export type RetailerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RetailerInclude | null
    /**
     * Filter, which Retailer to fetch.
     */
    where?: RetailerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retailers to fetch.
     */
    orderBy?: Enumerable<RetailerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Retailers.
     */
    cursor?: RetailerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retailers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retailers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Retailers.
     */
    distinct?: Enumerable<RetailerScalarFieldEnum>
  }

  /**
   * Retailer findFirst
   */
  export interface RetailerFindFirstArgs extends RetailerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Retailer findFirstOrThrow
   */
  export type RetailerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RetailerInclude | null
    /**
     * Filter, which Retailer to fetch.
     */
    where?: RetailerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retailers to fetch.
     */
    orderBy?: Enumerable<RetailerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Retailers.
     */
    cursor?: RetailerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retailers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retailers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Retailers.
     */
    distinct?: Enumerable<RetailerScalarFieldEnum>
  }


  /**
   * Retailer findMany
   */
  export type RetailerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RetailerInclude | null
    /**
     * Filter, which Retailers to fetch.
     */
    where?: RetailerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retailers to fetch.
     */
    orderBy?: Enumerable<RetailerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Retailers.
     */
    cursor?: RetailerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retailers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retailers.
     */
    skip?: number
    distinct?: Enumerable<RetailerScalarFieldEnum>
  }


  /**
   * Retailer create
   */
  export type RetailerCreateArgs = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RetailerInclude | null
    /**
     * The data needed to create a Retailer.
     */
    data: XOR<RetailerCreateInput, RetailerUncheckedCreateInput>
  }


  /**
   * Retailer createMany
   */
  export type RetailerCreateManyArgs = {
    /**
     * The data used to create many Retailers.
     */
    data: Enumerable<RetailerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Retailer update
   */
  export type RetailerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RetailerInclude | null
    /**
     * The data needed to update a Retailer.
     */
    data: XOR<RetailerUpdateInput, RetailerUncheckedUpdateInput>
    /**
     * Choose, which Retailer to update.
     */
    where: RetailerWhereUniqueInput
  }


  /**
   * Retailer updateMany
   */
  export type RetailerUpdateManyArgs = {
    /**
     * The data used to update Retailers.
     */
    data: XOR<RetailerUpdateManyMutationInput, RetailerUncheckedUpdateManyInput>
    /**
     * Filter which Retailers to update
     */
    where?: RetailerWhereInput
  }


  /**
   * Retailer upsert
   */
  export type RetailerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RetailerInclude | null
    /**
     * The filter to search for the Retailer to update in case it exists.
     */
    where: RetailerWhereUniqueInput
    /**
     * In case the Retailer found by the `where` argument doesn't exist, create a new Retailer with this data.
     */
    create: XOR<RetailerCreateInput, RetailerUncheckedCreateInput>
    /**
     * In case the Retailer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RetailerUpdateInput, RetailerUncheckedUpdateInput>
  }


  /**
   * Retailer delete
   */
  export type RetailerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RetailerInclude | null
    /**
     * Filter which Retailer to delete.
     */
    where: RetailerWhereUniqueInput
  }


  /**
   * Retailer deleteMany
   */
  export type RetailerDeleteManyArgs = {
    /**
     * Filter which Retailers to delete
     */
    where?: RetailerWhereInput
  }


  /**
   * Retailer.products
   */
  export type Retailer$productsArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Retailer.categorys
   */
  export type Retailer$categorysArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithRelationAndSearchRelevanceInput>
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Retailer without action
   */
  export type RetailerArgs = {
    /**
     * Select specific fields to fetch from the Retailer
     */
    select?: RetailerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RetailerInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const CategoryOrderByRelevanceFieldEnum: {
    name: 'name',
    keywords: 'keywords'
  };

  export type CategoryOrderByRelevanceFieldEnum = (typeof CategoryOrderByRelevanceFieldEnum)[keyof typeof CategoryOrderByRelevanceFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    keywords: 'keywords'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ClientOrderByRelevanceFieldEnum: {
    name: 'name',
    surname: 'surname',
    email: 'email',
    phone: 'phone',
    password: 'password',
    promocodes: 'promocodes'
  };

  export type ClientOrderByRelevanceFieldEnum = (typeof ClientOrderByRelevanceFieldEnum)[keyof typeof ClientOrderByRelevanceFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    surname: 'surname',
    email: 'email',
    phone: 'phone',
    password: 'password',
    emailConfirmed: 'emailConfirmed',
    createdAt: 'createdAt',
    promocodes: 'promocodes',
    wishlist: 'wishlist'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const DeliveryAddressOrderByRelevanceFieldEnum: {
    name: 'name',
    address: 'address'
  };

  export type DeliveryAddressOrderByRelevanceFieldEnum = (typeof DeliveryAddressOrderByRelevanceFieldEnum)[keyof typeof DeliveryAddressOrderByRelevanceFieldEnum]


  export const DeliveryAddressScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address'
  };

  export type DeliveryAddressScalarFieldEnum = (typeof DeliveryAddressScalarFieldEnum)[keyof typeof DeliveryAddressScalarFieldEnum]


  export const ModerationOrderByRelevanceFieldEnum: {
    login: 'login',
    password: 'password'
  };

  export type ModerationOrderByRelevanceFieldEnum = (typeof ModerationOrderByRelevanceFieldEnum)[keyof typeof ModerationOrderByRelevanceFieldEnum]


  export const ModerationScalarFieldEnum: {
    id: 'id',
    login: 'login',
    password: 'password'
  };

  export type ModerationScalarFieldEnum = (typeof ModerationScalarFieldEnum)[keyof typeof ModerationScalarFieldEnum]


  export const OrderOrderByRelevanceFieldEnum: {
    adress: 'adress'
  };

  export type OrderOrderByRelevanceFieldEnum = (typeof OrderOrderByRelevanceFieldEnum)[keyof typeof OrderOrderByRelevanceFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    dateCreated: 'dateCreated',
    confirmSuccess: 'confirmSuccess',
    adress: 'adress'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const ProductImageOrderByRelevanceFieldEnum: {
    path: 'path',
    alt: 'alt'
  };

  export type ProductImageOrderByRelevanceFieldEnum = (typeof ProductImageOrderByRelevanceFieldEnum)[keyof typeof ProductImageOrderByRelevanceFieldEnum]


  export const ProductImageScalarFieldEnum: {
    id: 'id',
    path: 'path',
    alt: 'alt',
    productId: 'productId'
  };

  export type ProductImageScalarFieldEnum = (typeof ProductImageScalarFieldEnum)[keyof typeof ProductImageScalarFieldEnum]


  export const ProductOnOrderScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    orderId: 'orderId',
    quantity: 'quantity',
    statusCode: 'statusCode'
  };

  export type ProductOnOrderScalarFieldEnum = (typeof ProductOnOrderScalarFieldEnum)[keyof typeof ProductOnOrderScalarFieldEnum]


  export const ProductOrderByRelevanceFieldEnum: {
    title: 'title',
    brand: 'brand',
    country: 'country',
    expires: 'expires',
    wayToUse: 'wayToUse',
    contain: 'contain',
    description: 'description',
    storage: 'storage',
    note: 'note'
  };

  export type ProductOrderByRelevanceFieldEnum = (typeof ProductOrderByRelevanceFieldEnum)[keyof typeof ProductOrderByRelevanceFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    title: 'title',
    amount: 'amount',
    price: 'price',
    brand: 'brand',
    country: 'country',
    expires: 'expires',
    wayToUse: 'wayToUse',
    contain: 'contain',
    description: 'description',
    storage: 'storage',
    note: 'note',
    visible: 'visible',
    retailerId: 'retailerId',
    clicks: 'clicks',
    createdAt: 'createdAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const ReportOrderByRelevanceFieldEnum: {
    title: 'title',
    text: 'text'
  };

  export type ReportOrderByRelevanceFieldEnum = (typeof ReportOrderByRelevanceFieldEnum)[keyof typeof ReportOrderByRelevanceFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    title: 'title',
    date: 'date',
    text: 'text'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const RetailerOrderByRelevanceFieldEnum: {
    email: 'email',
    photo: 'photo',
    name: 'name',
    surname: 'surname',
    patrinymic: 'patrinymic',
    phone: 'phone',
    companyName: 'companyName',
    city: 'city',
    password: 'password'
  };

  export type RetailerOrderByRelevanceFieldEnum = (typeof RetailerOrderByRelevanceFieldEnum)[keyof typeof RetailerOrderByRelevanceFieldEnum]


  export const RetailerScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailConfirmed: 'emailConfirmed',
    photo: 'photo',
    name: 'name',
    surname: 'surname',
    patrinymic: 'patrinymic',
    phone: 'phone',
    companyName: 'companyName',
    city: 'city',
    confirmed: 'confirmed',
    password: 'password'
  };

  export type RetailerScalarFieldEnum = (typeof RetailerScalarFieldEnum)[keyof typeof RetailerScalarFieldEnum]


  export const ReviewOrderByRelevanceFieldEnum: {
    title: 'title',
    text: 'text',
    retailerAnswer: 'retailerAnswer'
  };

  export type ReviewOrderByRelevanceFieldEnum = (typeof ReviewOrderByRelevanceFieldEnum)[keyof typeof ReviewOrderByRelevanceFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    clientId: 'clientId',
    createdAt: 'createdAt',
    lastEditTime: 'lastEditTime',
    title: 'title',
    text: 'text',
    rating: 'rating',
    retailerAnswer: 'retailerAnswer',
    answerCreatedAt: 'answerCreatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  /**
   * Deep Input Types
   */


  export type ModerationWhereInput = {
    AND?: Enumerable<ModerationWhereInput>
    OR?: Enumerable<ModerationWhereInput>
    NOT?: Enumerable<ModerationWhereInput>
    id?: IntFilter | number
    login?: StringFilter | string
    password?: StringFilter | string
  }

  export type ModerationOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    login?: SortOrder
    password?: SortOrder
    _relevance?: ModerationOrderByRelevanceInput
  }

  export type ModerationWhereUniqueInput = {
    id?: number
  }

  export type ModerationOrderByWithAggregationInput = {
    id?: SortOrder
    login?: SortOrder
    password?: SortOrder
    _count?: ModerationCountOrderByAggregateInput
    _avg?: ModerationAvgOrderByAggregateInput
    _max?: ModerationMaxOrderByAggregateInput
    _min?: ModerationMinOrderByAggregateInput
    _sum?: ModerationSumOrderByAggregateInput
  }

  export type ModerationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ModerationScalarWhereWithAggregatesInput>
    OR?: Enumerable<ModerationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ModerationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    login?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
  }

  export type ReportWhereInput = {
    AND?: Enumerable<ReportWhereInput>
    OR?: Enumerable<ReportWhereInput>
    NOT?: Enumerable<ReportWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    date?: DateTimeFilter | Date | string
    text?: StringFilter | string
  }

  export type ReportOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    text?: SortOrder
    _relevance?: ReportOrderByRelevanceInput
  }

  export type ReportWhereUniqueInput = {
    id?: number
  }

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    text?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReportScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReportScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    date?: DateTimeWithAggregatesFilter | Date | string
    text?: StringWithAggregatesFilter | string
  }

  export type DeliveryAddressWhereInput = {
    AND?: Enumerable<DeliveryAddressWhereInput>
    OR?: Enumerable<DeliveryAddressWhereInput>
    NOT?: Enumerable<DeliveryAddressWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    address?: StringFilter | string
  }

  export type DeliveryAddressOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    _relevance?: DeliveryAddressOrderByRelevanceInput
  }

  export type DeliveryAddressWhereUniqueInput = {
    id?: number
  }

  export type DeliveryAddressOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    _count?: DeliveryAddressCountOrderByAggregateInput
    _avg?: DeliveryAddressAvgOrderByAggregateInput
    _max?: DeliveryAddressMaxOrderByAggregateInput
    _min?: DeliveryAddressMinOrderByAggregateInput
    _sum?: DeliveryAddressSumOrderByAggregateInput
  }

  export type DeliveryAddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeliveryAddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeliveryAddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeliveryAddressScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
  }

  export type ClientWhereInput = {
    AND?: Enumerable<ClientWhereInput>
    OR?: Enumerable<ClientWhereInput>
    NOT?: Enumerable<ClientWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    surname?: StringFilter | string
    email?: StringFilter | string
    phone?: StringNullableFilter | string | null
    password?: StringFilter | string
    emailConfirmed?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    promocodes?: StringNullableListFilter
    wishlist?: IntNullableListFilter
    orders?: OrderListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type ClientOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    emailConfirmed?: SortOrder
    createdAt?: SortOrder
    promocodes?: SortOrder
    wishlist?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    _relevance?: ClientOrderByRelevanceInput
  }

  export type ClientWhereUniqueInput = {
    id?: number
    email?: string
    phone?: string
  }

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    emailConfirmed?: SortOrder
    createdAt?: SortOrder
    promocodes?: SortOrder
    wishlist?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClientScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClientScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    surname?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phone?: StringNullableWithAggregatesFilter | string | null
    password?: StringWithAggregatesFilter | string
    emailConfirmed?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    promocodes?: StringNullableListFilter
    wishlist?: IntNullableListFilter
  }

  export type OrderWhereInput = {
    AND?: Enumerable<OrderWhereInput>
    OR?: Enumerable<OrderWhereInput>
    NOT?: Enumerable<OrderWhereInput>
    id?: IntFilter | number
    clientId?: IntFilter | number
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    dateCreated?: DateTimeFilter | Date | string
    confirmSuccess?: BoolFilter | boolean
    products?: ProductOnOrderListRelationFilter
    adress?: StringFilter | string
  }

  export type OrderOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    clientId?: SortOrder
    client?: ClientOrderByWithRelationAndSearchRelevanceInput
    dateCreated?: SortOrder
    confirmSuccess?: SortOrder
    products?: ProductOnOrderOrderByRelationAggregateInput
    adress?: SortOrder
    _relevance?: OrderOrderByRelevanceInput
  }

  export type OrderWhereUniqueInput = {
    id?: number
  }

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    dateCreated?: SortOrder
    confirmSuccess?: SortOrder
    adress?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    clientId?: IntWithAggregatesFilter | number
    dateCreated?: DateTimeWithAggregatesFilter | Date | string
    confirmSuccess?: BoolWithAggregatesFilter | boolean
    adress?: StringWithAggregatesFilter | string
  }

  export type ProductOnOrderWhereInput = {
    AND?: Enumerable<ProductOnOrderWhereInput>
    OR?: Enumerable<ProductOnOrderWhereInput>
    NOT?: Enumerable<ProductOnOrderWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    orderId?: IntFilter | number
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    quantity?: IntFilter | number
    statusCode?: IntFilter | number
  }

  export type ProductOnOrderOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationAndSearchRelevanceInput
    orderId?: SortOrder
    order?: OrderOrderByWithRelationAndSearchRelevanceInput
    quantity?: SortOrder
    statusCode?: SortOrder
  }

  export type ProductOnOrderWhereUniqueInput = {
    id?: number
  }

  export type ProductOnOrderOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    statusCode?: SortOrder
    _count?: ProductOnOrderCountOrderByAggregateInput
    _avg?: ProductOnOrderAvgOrderByAggregateInput
    _max?: ProductOnOrderMaxOrderByAggregateInput
    _min?: ProductOnOrderMinOrderByAggregateInput
    _sum?: ProductOnOrderSumOrderByAggregateInput
  }

  export type ProductOnOrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductOnOrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductOnOrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductOnOrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    orderId?: IntWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
    statusCode?: IntWithAggregatesFilter | number
  }

  export type ReviewWhereInput = {
    AND?: Enumerable<ReviewWhereInput>
    OR?: Enumerable<ReviewWhereInput>
    NOT?: Enumerable<ReviewWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    clientId?: IntFilter | number
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    createdAt?: DateTimeFilter | Date | string
    lastEditTime?: DateTimeFilter | Date | string
    title?: StringFilter | string
    text?: StringFilter | string
    rating?: IntFilter | number
    retailerAnswer?: StringNullableFilter | string | null
    answerCreatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ReviewOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationAndSearchRelevanceInput
    clientId?: SortOrder
    client?: ClientOrderByWithRelationAndSearchRelevanceInput
    createdAt?: SortOrder
    lastEditTime?: SortOrder
    title?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    retailerAnswer?: SortOrder
    answerCreatedAt?: SortOrder
    _relevance?: ReviewOrderByRelevanceInput
  }

  export type ReviewWhereUniqueInput = {
    id?: number
  }

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    lastEditTime?: SortOrder
    title?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    retailerAnswer?: SortOrder
    answerCreatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReviewScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    clientId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    lastEditTime?: DateTimeWithAggregatesFilter | Date | string
    title?: StringWithAggregatesFilter | string
    text?: StringWithAggregatesFilter | string
    rating?: IntWithAggregatesFilter | number
    retailerAnswer?: StringNullableWithAggregatesFilter | string | null
    answerCreatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    amount?: IntFilter | number
    price?: IntFilter | number
    brand?: StringFilter | string
    country?: StringNullableFilter | string | null
    expires?: StringNullableFilter | string | null
    wayToUse?: StringNullableFilter | string | null
    contain?: StringNullableFilter | string | null
    description?: StringFilter | string
    storage?: StringFilter | string
    note?: StringNullableFilter | string | null
    visible?: BoolFilter | boolean
    retailerId?: IntFilter | number
    retailer?: XOR<RetailerRelationFilter, RetailerWhereInput>
    clicks?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    categories?: CategoryListRelationFilter
    images?: ProductImageListRelationFilter
    reviews?: ReviewListRelationFilter
    orders?: ProductOnOrderListRelationFilter
  }

  export type ProductOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    brand?: SortOrder
    country?: SortOrder
    expires?: SortOrder
    wayToUse?: SortOrder
    contain?: SortOrder
    description?: SortOrder
    storage?: SortOrder
    note?: SortOrder
    visible?: SortOrder
    retailerId?: SortOrder
    retailer?: RetailerOrderByWithRelationAndSearchRelevanceInput
    clicks?: SortOrder
    createdAt?: SortOrder
    categories?: CategoryOrderByRelationAggregateInput
    images?: ProductImageOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    orders?: ProductOnOrderOrderByRelationAggregateInput
    _relevance?: ProductOrderByRelevanceInput
  }

  export type ProductWhereUniqueInput = {
    id?: number
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    brand?: SortOrder
    country?: SortOrder
    expires?: SortOrder
    wayToUse?: SortOrder
    contain?: SortOrder
    description?: SortOrder
    storage?: SortOrder
    note?: SortOrder
    visible?: SortOrder
    retailerId?: SortOrder
    clicks?: SortOrder
    createdAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    amount?: IntWithAggregatesFilter | number
    price?: IntWithAggregatesFilter | number
    brand?: StringWithAggregatesFilter | string
    country?: StringNullableWithAggregatesFilter | string | null
    expires?: StringNullableWithAggregatesFilter | string | null
    wayToUse?: StringNullableWithAggregatesFilter | string | null
    contain?: StringNullableWithAggregatesFilter | string | null
    description?: StringWithAggregatesFilter | string
    storage?: StringWithAggregatesFilter | string
    note?: StringNullableWithAggregatesFilter | string | null
    visible?: BoolWithAggregatesFilter | boolean
    retailerId?: IntWithAggregatesFilter | number
    clicks?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductImageWhereInput = {
    AND?: Enumerable<ProductImageWhereInput>
    OR?: Enumerable<ProductImageWhereInput>
    NOT?: Enumerable<ProductImageWhereInput>
    id?: IntFilter | number
    path?: StringFilter | string
    alt?: StringFilter | string
    productId?: IntFilter | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type ProductImageOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    path?: SortOrder
    alt?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationAndSearchRelevanceInput
    _relevance?: ProductImageOrderByRelevanceInput
  }

  export type ProductImageWhereUniqueInput = {
    id?: number
  }

  export type ProductImageOrderByWithAggregationInput = {
    id?: SortOrder
    path?: SortOrder
    alt?: SortOrder
    productId?: SortOrder
    _count?: ProductImageCountOrderByAggregateInput
    _avg?: ProductImageAvgOrderByAggregateInput
    _max?: ProductImageMaxOrderByAggregateInput
    _min?: ProductImageMinOrderByAggregateInput
    _sum?: ProductImageSumOrderByAggregateInput
  }

  export type ProductImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductImageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    path?: StringWithAggregatesFilter | string
    alt?: StringWithAggregatesFilter | string
    productId?: IntWithAggregatesFilter | number
  }

  export type CategoryWhereInput = {
    AND?: Enumerable<CategoryWhereInput>
    OR?: Enumerable<CategoryWhereInput>
    NOT?: Enumerable<CategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    keywords?: StringNullableListFilter
    products?: ProductListRelationFilter
    retailers?: RetailerListRelationFilter
  }

  export type CategoryOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    keywords?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    retailers?: RetailerOrderByRelationAggregateInput
    _relevance?: CategoryOrderByRelevanceInput
  }

  export type CategoryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    keywords?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    keywords?: StringNullableListFilter
  }

  export type RetailerWhereInput = {
    AND?: Enumerable<RetailerWhereInput>
    OR?: Enumerable<RetailerWhereInput>
    NOT?: Enumerable<RetailerWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    emailConfirmed?: BoolFilter | boolean
    photo?: StringFilter | string
    name?: StringFilter | string
    surname?: StringFilter | string
    patrinymic?: StringFilter | string
    phone?: StringNullableFilter | string | null
    companyName?: StringFilter | string
    city?: StringFilter | string
    confirmed?: BoolFilter | boolean
    password?: StringFilter | string
    products?: ProductListRelationFilter
    categorys?: CategoryListRelationFilter
  }

  export type RetailerOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    email?: SortOrder
    emailConfirmed?: SortOrder
    photo?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    patrinymic?: SortOrder
    phone?: SortOrder
    companyName?: SortOrder
    city?: SortOrder
    confirmed?: SortOrder
    password?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    categorys?: CategoryOrderByRelationAggregateInput
    _relevance?: RetailerOrderByRelevanceInput
  }

  export type RetailerWhereUniqueInput = {
    id?: number
    email?: string
    phone?: string
    companyName?: string
  }

  export type RetailerOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    emailConfirmed?: SortOrder
    photo?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    patrinymic?: SortOrder
    phone?: SortOrder
    companyName?: SortOrder
    city?: SortOrder
    confirmed?: SortOrder
    password?: SortOrder
    _count?: RetailerCountOrderByAggregateInput
    _avg?: RetailerAvgOrderByAggregateInput
    _max?: RetailerMaxOrderByAggregateInput
    _min?: RetailerMinOrderByAggregateInput
    _sum?: RetailerSumOrderByAggregateInput
  }

  export type RetailerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RetailerScalarWhereWithAggregatesInput>
    OR?: Enumerable<RetailerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RetailerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    emailConfirmed?: BoolWithAggregatesFilter | boolean
    photo?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    surname?: StringWithAggregatesFilter | string
    patrinymic?: StringWithAggregatesFilter | string
    phone?: StringNullableWithAggregatesFilter | string | null
    companyName?: StringWithAggregatesFilter | string
    city?: StringWithAggregatesFilter | string
    confirmed?: BoolWithAggregatesFilter | boolean
    password?: StringWithAggregatesFilter | string
  }

  export type ModerationCreateInput = {
    login: string
    password: string
  }

  export type ModerationUncheckedCreateInput = {
    id?: number
    login: string
    password: string
  }

  export type ModerationUpdateInput = {
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationCreateManyInput = {
    id?: number
    login: string
    password: string
  }

  export type ModerationUpdateManyMutationInput = {
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ReportCreateInput = {
    title: string
    date?: Date | string
    text: string
  }

  export type ReportUncheckedCreateInput = {
    id?: number
    title: string
    date?: Date | string
    text: string
  }

  export type ReportUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type ReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type ReportCreateManyInput = {
    id?: number
    title: string
    date?: Date | string
    text: string
  }

  export type ReportUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryAddressCreateInput = {
    name: string
    address: string
  }

  export type DeliveryAddressUncheckedCreateInput = {
    id?: number
    name: string
    address: string
  }

  export type DeliveryAddressUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryAddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryAddressCreateManyInput = {
    id?: number
    name: string
    address: string
  }

  export type DeliveryAddressUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryAddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type ClientCreateInput = {
    name: string
    surname: string
    email: string
    phone?: string | null
    password: string
    emailConfirmed?: boolean
    createdAt?: Date | string
    promocodes?: ClientCreatepromocodesInput | Enumerable<string>
    wishlist?: ClientCreatewishlistInput | Enumerable<number>
    orders?: OrderCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: number
    name: string
    surname: string
    email: string
    phone?: string | null
    password: string
    emailConfirmed?: boolean
    createdAt?: Date | string
    promocodes?: ClientCreatepromocodesInput | Enumerable<string>
    wishlist?: ClientCreatewishlistInput | Enumerable<number>
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promocodes?: ClientUpdatepromocodesInput | Enumerable<string>
    wishlist?: ClientUpdatewishlistInput | Enumerable<number>
    orders?: OrderUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promocodes?: ClientUpdatepromocodesInput | Enumerable<string>
    wishlist?: ClientUpdatewishlistInput | Enumerable<number>
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: number
    name: string
    surname: string
    email: string
    phone?: string | null
    password: string
    emailConfirmed?: boolean
    createdAt?: Date | string
    promocodes?: ClientCreatepromocodesInput | Enumerable<string>
    wishlist?: ClientCreatewishlistInput | Enumerable<number>
  }

  export type ClientUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promocodes?: ClientUpdatepromocodesInput | Enumerable<string>
    wishlist?: ClientUpdatewishlistInput | Enumerable<number>
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promocodes?: ClientUpdatepromocodesInput | Enumerable<string>
    wishlist?: ClientUpdatewishlistInput | Enumerable<number>
  }

  export type OrderCreateInput = {
    client: ClientCreateNestedOneWithoutOrdersInput
    dateCreated?: Date | string
    confirmSuccess: boolean
    products?: ProductOnOrderCreateNestedManyWithoutOrderInput
    adress?: string
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    clientId: number
    dateCreated?: Date | string
    confirmSuccess: boolean
    products?: ProductOnOrderUncheckedCreateNestedManyWithoutOrderInput
    adress?: string
  }

  export type OrderUpdateInput = {
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmSuccess?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductOnOrderUpdateManyWithoutOrderNestedInput
    adress?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmSuccess?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductOnOrderUncheckedUpdateManyWithoutOrderNestedInput
    adress?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateManyInput = {
    id?: number
    clientId: number
    dateCreated?: Date | string
    confirmSuccess: boolean
    adress?: string
  }

  export type OrderUpdateManyMutationInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmSuccess?: BoolFieldUpdateOperationsInput | boolean
    adress?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmSuccess?: BoolFieldUpdateOperationsInput | boolean
    adress?: StringFieldUpdateOperationsInput | string
  }

  export type ProductOnOrderCreateInput = {
    product: ProductCreateNestedOneWithoutOrdersInput
    order: OrderCreateNestedOneWithoutProductsInput
    quantity?: number
    statusCode: number
  }

  export type ProductOnOrderUncheckedCreateInput = {
    id?: number
    productId: number
    orderId: number
    quantity?: number
    statusCode: number
  }

  export type ProductOnOrderUpdateInput = {
    product?: ProductUpdateOneRequiredWithoutOrdersNestedInput
    order?: OrderUpdateOneRequiredWithoutProductsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    statusCode?: IntFieldUpdateOperationsInput | number
  }

  export type ProductOnOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    statusCode?: IntFieldUpdateOperationsInput | number
  }

  export type ProductOnOrderCreateManyInput = {
    id?: number
    productId: number
    orderId: number
    quantity?: number
    statusCode: number
  }

  export type ProductOnOrderUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    statusCode?: IntFieldUpdateOperationsInput | number
  }

  export type ProductOnOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    statusCode?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCreateInput = {
    product: ProductCreateNestedOneWithoutReviewsInput
    client: ClientCreateNestedOneWithoutReviewsInput
    createdAt?: Date | string
    lastEditTime?: Date | string
    title: string
    text: string
    rating: number
    retailerAnswer?: string | null
    answerCreatedAt?: Date | string | null
  }

  export type ReviewUncheckedCreateInput = {
    id?: number
    productId: number
    clientId: number
    createdAt?: Date | string
    lastEditTime?: Date | string
    title: string
    text: string
    rating: number
    retailerAnswer?: string | null
    answerCreatedAt?: Date | string | null
  }

  export type ReviewUpdateInput = {
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
    client?: ClientUpdateOneRequiredWithoutReviewsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    retailerAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    answerCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    retailerAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    answerCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewCreateManyInput = {
    id?: number
    productId: number
    clientId: number
    createdAt?: Date | string
    lastEditTime?: Date | string
    title: string
    text: string
    rating: number
    retailerAnswer?: string | null
    answerCreatedAt?: Date | string | null
  }

  export type ReviewUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    retailerAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    answerCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    retailerAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    answerCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateInput = {
    title: string
    amount?: number
    price: number
    brand: string
    country?: string | null
    expires?: string | null
    wayToUse?: string | null
    contain?: string | null
    description: string
    storage: string
    note?: string | null
    visible?: boolean
    retailer: RetailerCreateNestedOneWithoutProductsInput
    clicks?: number
    createdAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    orders?: ProductOnOrderCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    title: string
    amount?: number
    price: number
    brand: string
    country?: string | null
    expires?: string | null
    wayToUse?: string | null
    contain?: string | null
    description: string
    storage: string
    note?: string | null
    visible?: boolean
    retailerId: number
    clicks?: number
    createdAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: ProductOnOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    retailer?: RetailerUpdateOneRequiredWithoutProductsNestedInput
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    orders?: ProductOnOrderUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    retailerId?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: ProductOnOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    title: string
    amount?: number
    price: number
    brand: string
    country?: string | null
    expires?: string | null
    wayToUse?: string | null
    contain?: string | null
    description: string
    storage: string
    note?: string | null
    visible?: boolean
    retailerId: number
    clicks?: number
    createdAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    retailerId?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageCreateInput = {
    path: string
    alt: string
    product: ProductCreateNestedOneWithoutImagesInput
  }

  export type ProductImageUncheckedCreateInput = {
    id?: number
    path: string
    alt: string
    productId: number
  }

  export type ProductImageUpdateInput = {
    path?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ProductImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductImageCreateManyInput = {
    id?: number
    path: string
    alt: string
    productId: number
  }

  export type ProductImageUpdateManyMutationInput = {
    path?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
  }

  export type ProductImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type CategoryCreateInput = {
    name: string
    keywords?: CategoryCreatekeywordsInput | Enumerable<string>
    products?: ProductCreateNestedManyWithoutCategoriesInput
    retailers?: RetailerCreateNestedManyWithoutCategorysInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    keywords?: CategoryCreatekeywordsInput | Enumerable<string>
    products?: ProductUncheckedCreateNestedManyWithoutCategoriesInput
    retailers?: RetailerUncheckedCreateNestedManyWithoutCategorysInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    keywords?: CategoryUpdatekeywordsInput | Enumerable<string>
    products?: ProductUpdateManyWithoutCategoriesNestedInput
    retailers?: RetailerUpdateManyWithoutCategorysNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    keywords?: CategoryUpdatekeywordsInput | Enumerable<string>
    products?: ProductUncheckedUpdateManyWithoutCategoriesNestedInput
    retailers?: RetailerUncheckedUpdateManyWithoutCategorysNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    keywords?: CategoryCreatekeywordsInput | Enumerable<string>
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    keywords?: CategoryUpdatekeywordsInput | Enumerable<string>
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    keywords?: CategoryUpdatekeywordsInput | Enumerable<string>
  }

  export type RetailerCreateInput = {
    email: string
    emailConfirmed?: boolean
    photo: string
    name: string
    surname: string
    patrinymic: string
    phone?: string | null
    companyName: string
    city: string
    confirmed?: boolean
    password: string
    products?: ProductCreateNestedManyWithoutRetailerInput
    categorys?: CategoryCreateNestedManyWithoutRetailersInput
  }

  export type RetailerUncheckedCreateInput = {
    id?: number
    email: string
    emailConfirmed?: boolean
    photo: string
    name: string
    surname: string
    patrinymic: string
    phone?: string | null
    companyName: string
    city: string
    confirmed?: boolean
    password: string
    products?: ProductUncheckedCreateNestedManyWithoutRetailerInput
    categorys?: CategoryUncheckedCreateNestedManyWithoutRetailersInput
  }

  export type RetailerUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    patrinymic?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutRetailerNestedInput
    categorys?: CategoryUpdateManyWithoutRetailersNestedInput
  }

  export type RetailerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    patrinymic?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutRetailerNestedInput
    categorys?: CategoryUncheckedUpdateManyWithoutRetailersNestedInput
  }

  export type RetailerCreateManyInput = {
    id?: number
    email: string
    emailConfirmed?: boolean
    photo: string
    name: string
    surname: string
    patrinymic: string
    phone?: string | null
    companyName: string
    city: string
    confirmed?: boolean
    password: string
  }

  export type RetailerUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    patrinymic?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
  }

  export type RetailerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    patrinymic?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type ModerationOrderByRelevanceInput = {
    fields: Enumerable<ModerationOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ModerationCountOrderByAggregateInput = {
    id?: SortOrder
    login?: SortOrder
    password?: SortOrder
  }

  export type ModerationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ModerationMaxOrderByAggregateInput = {
    id?: SortOrder
    login?: SortOrder
    password?: SortOrder
  }

  export type ModerationMinOrderByAggregateInput = {
    id?: SortOrder
    login?: SortOrder
    password?: SortOrder
  }

  export type ModerationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ReportOrderByRelevanceInput = {
    fields: Enumerable<ReportOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    text?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    text?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    text?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DeliveryAddressOrderByRelevanceInput = {
    fields: Enumerable<DeliveryAddressOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type DeliveryAddressCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
  }

  export type DeliveryAddressAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeliveryAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
  }

  export type DeliveryAddressMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
  }

  export type DeliveryAddressSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type IntNullableListFilter = {
    equals?: Enumerable<number> | null
    has?: number | null
    hasEvery?: Enumerable<number>
    hasSome?: Enumerable<number>
    isEmpty?: boolean
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelevanceInput = {
    fields: Enumerable<ClientOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    emailConfirmed?: SortOrder
    createdAt?: SortOrder
    promocodes?: SortOrder
    wishlist?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    id?: SortOrder
    wishlist?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    emailConfirmed?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    emailConfirmed?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    id?: SortOrder
    wishlist?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type ClientRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ProductOnOrderListRelationFilter = {
    every?: ProductOnOrderWhereInput
    some?: ProductOnOrderWhereInput
    none?: ProductOnOrderWhereInput
  }

  export type ProductOnOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelevanceInput = {
    fields: Enumerable<OrderOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    dateCreated?: SortOrder
    confirmSuccess?: SortOrder
    adress?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    dateCreated?: SortOrder
    confirmSuccess?: SortOrder
    adress?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    dateCreated?: SortOrder
    confirmSuccess?: SortOrder
    adress?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ProductOnOrderCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    statusCode?: SortOrder
  }

  export type ProductOnOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    statusCode?: SortOrder
  }

  export type ProductOnOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    statusCode?: SortOrder
  }

  export type ProductOnOrderMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    statusCode?: SortOrder
  }

  export type ProductOnOrderSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    statusCode?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type ReviewOrderByRelevanceInput = {
    fields: Enumerable<ReviewOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    lastEditTime?: SortOrder
    title?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    retailerAnswer?: SortOrder
    answerCreatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    lastEditTime?: SortOrder
    title?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    retailerAnswer?: SortOrder
    answerCreatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    lastEditTime?: SortOrder
    title?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    retailerAnswer?: SortOrder
    answerCreatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type RetailerRelationFilter = {
    is?: RetailerWhereInput
    isNot?: RetailerWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type ProductImageListRelationFilter = {
    every?: ProductImageWhereInput
    some?: ProductImageWhereInput
    none?: ProductImageWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelevanceInput = {
    fields: Enumerable<ProductOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    brand?: SortOrder
    country?: SortOrder
    expires?: SortOrder
    wayToUse?: SortOrder
    contain?: SortOrder
    description?: SortOrder
    storage?: SortOrder
    note?: SortOrder
    visible?: SortOrder
    retailerId?: SortOrder
    clicks?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    retailerId?: SortOrder
    clicks?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    brand?: SortOrder
    country?: SortOrder
    expires?: SortOrder
    wayToUse?: SortOrder
    contain?: SortOrder
    description?: SortOrder
    storage?: SortOrder
    note?: SortOrder
    visible?: SortOrder
    retailerId?: SortOrder
    clicks?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    brand?: SortOrder
    country?: SortOrder
    expires?: SortOrder
    wayToUse?: SortOrder
    contain?: SortOrder
    description?: SortOrder
    storage?: SortOrder
    note?: SortOrder
    visible?: SortOrder
    retailerId?: SortOrder
    clicks?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    retailerId?: SortOrder
    clicks?: SortOrder
  }

  export type ProductImageOrderByRelevanceInput = {
    fields: Enumerable<ProductImageOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ProductImageCountOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    alt?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageMaxOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    alt?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageMinOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    alt?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type RetailerListRelationFilter = {
    every?: RetailerWhereInput
    some?: RetailerWhereInput
    none?: RetailerWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RetailerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelevanceInput = {
    fields: Enumerable<CategoryOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    keywords?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RetailerOrderByRelevanceInput = {
    fields: Enumerable<RetailerOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RetailerCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailConfirmed?: SortOrder
    photo?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    patrinymic?: SortOrder
    phone?: SortOrder
    companyName?: SortOrder
    city?: SortOrder
    confirmed?: SortOrder
    password?: SortOrder
  }

  export type RetailerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RetailerMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailConfirmed?: SortOrder
    photo?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    patrinymic?: SortOrder
    phone?: SortOrder
    companyName?: SortOrder
    city?: SortOrder
    confirmed?: SortOrder
    password?: SortOrder
  }

  export type RetailerMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailConfirmed?: SortOrder
    photo?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    patrinymic?: SortOrder
    phone?: SortOrder
    companyName?: SortOrder
    city?: SortOrder
    confirmed?: SortOrder
    password?: SortOrder
  }

  export type RetailerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClientCreatepromocodesInput = {
    set: Enumerable<string>
  }

  export type ClientCreatewishlistInput = {
    set: Enumerable<number>
  }

  export type OrderCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<OrderCreateWithoutClientInput>, Enumerable<OrderUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutClientInput>
    createMany?: OrderCreateManyClientInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type ReviewCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutClientInput>, Enumerable<ReviewUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutClientInput>
    createMany?: ReviewCreateManyClientInputEnvelope
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<OrderCreateWithoutClientInput>, Enumerable<OrderUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutClientInput>
    createMany?: OrderCreateManyClientInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type ReviewUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutClientInput>, Enumerable<ReviewUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutClientInput>
    createMany?: ReviewCreateManyClientInputEnvelope
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ClientUpdatepromocodesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ClientUpdatewishlistInput = {
    set?: Enumerable<number>
    push?: number | Enumerable<number>
  }

  export type OrderUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutClientInput>, Enumerable<OrderUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutClientInput>
    createMany?: OrderCreateManyClientInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type ReviewUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutClientInput>, Enumerable<ReviewUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutClientInput>
    createMany?: ReviewCreateManyClientInputEnvelope
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutClientInput>, Enumerable<OrderUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutClientInput>
    createMany?: OrderCreateManyClientInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type ReviewUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutClientInput>, Enumerable<ReviewUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutClientInput>
    createMany?: ReviewCreateManyClientInputEnvelope
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type ClientCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOrdersInput
    connect?: ClientWhereUniqueInput
  }

  export type ProductOnOrderCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<ProductOnOrderCreateWithoutOrderInput>, Enumerable<ProductOnOrderUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<ProductOnOrderCreateOrConnectWithoutOrderInput>
    createMany?: ProductOnOrderCreateManyOrderInputEnvelope
    connect?: Enumerable<ProductOnOrderWhereUniqueInput>
  }

  export type ProductOnOrderUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<ProductOnOrderCreateWithoutOrderInput>, Enumerable<ProductOnOrderUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<ProductOnOrderCreateOrConnectWithoutOrderInput>
    createMany?: ProductOnOrderCreateManyOrderInputEnvelope
    connect?: Enumerable<ProductOnOrderWhereUniqueInput>
  }

  export type ClientUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOrdersInput
    upsert?: ClientUpsertWithoutOrdersInput
    connect?: ClientWhereUniqueInput
    update?: XOR<ClientUpdateWithoutOrdersInput, ClientUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductOnOrderUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<ProductOnOrderCreateWithoutOrderInput>, Enumerable<ProductOnOrderUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<ProductOnOrderCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<ProductOnOrderUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: ProductOnOrderCreateManyOrderInputEnvelope
    set?: Enumerable<ProductOnOrderWhereUniqueInput>
    disconnect?: Enumerable<ProductOnOrderWhereUniqueInput>
    delete?: Enumerable<ProductOnOrderWhereUniqueInput>
    connect?: Enumerable<ProductOnOrderWhereUniqueInput>
    update?: Enumerable<ProductOnOrderUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<ProductOnOrderUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<ProductOnOrderScalarWhereInput>
  }

  export type ProductOnOrderUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<ProductOnOrderCreateWithoutOrderInput>, Enumerable<ProductOnOrderUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<ProductOnOrderCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<ProductOnOrderUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: ProductOnOrderCreateManyOrderInputEnvelope
    set?: Enumerable<ProductOnOrderWhereUniqueInput>
    disconnect?: Enumerable<ProductOnOrderWhereUniqueInput>
    delete?: Enumerable<ProductOnOrderWhereUniqueInput>
    connect?: Enumerable<ProductOnOrderWhereUniqueInput>
    update?: Enumerable<ProductOnOrderUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<ProductOnOrderUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<ProductOnOrderScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutProductsInput = {
    create?: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutProductsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput
    upsert?: ProductUpsertWithoutOrdersInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutProductsInput
    upsert?: OrderUpsertWithoutProductsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutProductsInput, OrderUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    connect?: ProductWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReviewsInput
    connect?: ClientWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    upsert?: ProductUpsertWithoutReviewsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type ClientUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReviewsInput
    upsert?: ClientUpsertWithoutReviewsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<ClientUpdateWithoutReviewsInput, ClientUncheckedUpdateWithoutReviewsInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type RetailerCreateNestedOneWithoutProductsInput = {
    create?: XOR<RetailerCreateWithoutProductsInput, RetailerUncheckedCreateWithoutProductsInput>
    connectOrCreate?: RetailerCreateOrConnectWithoutProductsInput
    connect?: RetailerWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutProductsInput>, Enumerable<CategoryUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type ProductImageCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductImageCreateWithoutProductInput>, Enumerable<ProductImageUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductImageCreateOrConnectWithoutProductInput>
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: Enumerable<ProductImageWhereUniqueInput>
  }

  export type ReviewCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutProductInput>, Enumerable<ReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutProductInput>
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type ProductOnOrderCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductOnOrderCreateWithoutProductInput>, Enumerable<ProductOnOrderUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductOnOrderCreateOrConnectWithoutProductInput>
    createMany?: ProductOnOrderCreateManyProductInputEnvelope
    connect?: Enumerable<ProductOnOrderWhereUniqueInput>
  }

  export type CategoryUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutProductsInput>, Enumerable<CategoryUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type ProductImageUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductImageCreateWithoutProductInput>, Enumerable<ProductImageUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductImageCreateOrConnectWithoutProductInput>
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: Enumerable<ProductImageWhereUniqueInput>
  }

  export type ReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutProductInput>, Enumerable<ReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutProductInput>
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type ProductOnOrderUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductOnOrderCreateWithoutProductInput>, Enumerable<ProductOnOrderUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductOnOrderCreateOrConnectWithoutProductInput>
    createMany?: ProductOnOrderCreateManyProductInputEnvelope
    connect?: Enumerable<ProductOnOrderWhereUniqueInput>
  }

  export type RetailerUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<RetailerCreateWithoutProductsInput, RetailerUncheckedCreateWithoutProductsInput>
    connectOrCreate?: RetailerCreateOrConnectWithoutProductsInput
    upsert?: RetailerUpsertWithoutProductsInput
    connect?: RetailerWhereUniqueInput
    update?: XOR<RetailerUpdateWithoutProductsInput, RetailerUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutProductsInput>, Enumerable<CategoryUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type ProductImageUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductImageCreateWithoutProductInput>, Enumerable<ProductImageUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductImageCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductImageUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: Enumerable<ProductImageWhereUniqueInput>
    disconnect?: Enumerable<ProductImageWhereUniqueInput>
    delete?: Enumerable<ProductImageWhereUniqueInput>
    connect?: Enumerable<ProductImageWhereUniqueInput>
    update?: Enumerable<ProductImageUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductImageUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductImageScalarWhereInput>
  }

  export type ReviewUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutProductInput>, Enumerable<ReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type ProductOnOrderUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductOnOrderCreateWithoutProductInput>, Enumerable<ProductOnOrderUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductOnOrderCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductOnOrderUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductOnOrderCreateManyProductInputEnvelope
    set?: Enumerable<ProductOnOrderWhereUniqueInput>
    disconnect?: Enumerable<ProductOnOrderWhereUniqueInput>
    delete?: Enumerable<ProductOnOrderWhereUniqueInput>
    connect?: Enumerable<ProductOnOrderWhereUniqueInput>
    update?: Enumerable<ProductOnOrderUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductOnOrderUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductOnOrderScalarWhereInput>
  }

  export type CategoryUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutProductsInput>, Enumerable<CategoryUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type ProductImageUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductImageCreateWithoutProductInput>, Enumerable<ProductImageUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductImageCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductImageUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: Enumerable<ProductImageWhereUniqueInput>
    disconnect?: Enumerable<ProductImageWhereUniqueInput>
    delete?: Enumerable<ProductImageWhereUniqueInput>
    connect?: Enumerable<ProductImageWhereUniqueInput>
    update?: Enumerable<ProductImageUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductImageUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductImageScalarWhereInput>
  }

  export type ReviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutProductInput>, Enumerable<ReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type ProductOnOrderUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductOnOrderCreateWithoutProductInput>, Enumerable<ProductOnOrderUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductOnOrderCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductOnOrderUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductOnOrderCreateManyProductInputEnvelope
    set?: Enumerable<ProductOnOrderWhereUniqueInput>
    disconnect?: Enumerable<ProductOnOrderWhereUniqueInput>
    delete?: Enumerable<ProductOnOrderWhereUniqueInput>
    connect?: Enumerable<ProductOnOrderWhereUniqueInput>
    update?: Enumerable<ProductOnOrderUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductOnOrderUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductOnOrderScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutImagesInput = {
    create?: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImagesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImagesInput
    upsert?: ProductUpsertWithoutImagesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutImagesInput, ProductUncheckedUpdateWithoutImagesInput>
  }

  export type CategoryCreatekeywordsInput = {
    set: Enumerable<string>
  }

  export type ProductCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCategoriesInput>, Enumerable<ProductUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCategoriesInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type RetailerCreateNestedManyWithoutCategorysInput = {
    create?: XOR<Enumerable<RetailerCreateWithoutCategorysInput>, Enumerable<RetailerUncheckedCreateWithoutCategorysInput>>
    connectOrCreate?: Enumerable<RetailerCreateOrConnectWithoutCategorysInput>
    connect?: Enumerable<RetailerWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCategoriesInput>, Enumerable<ProductUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCategoriesInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type RetailerUncheckedCreateNestedManyWithoutCategorysInput = {
    create?: XOR<Enumerable<RetailerCreateWithoutCategorysInput>, Enumerable<RetailerUncheckedCreateWithoutCategorysInput>>
    connectOrCreate?: Enumerable<RetailerCreateOrConnectWithoutCategorysInput>
    connect?: Enumerable<RetailerWhereUniqueInput>
  }

  export type CategoryUpdatekeywordsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProductUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCategoriesInput>, Enumerable<ProductUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCategoriesInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutCategoriesInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutCategoriesInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutCategoriesInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type RetailerUpdateManyWithoutCategorysNestedInput = {
    create?: XOR<Enumerable<RetailerCreateWithoutCategorysInput>, Enumerable<RetailerUncheckedCreateWithoutCategorysInput>>
    connectOrCreate?: Enumerable<RetailerCreateOrConnectWithoutCategorysInput>
    upsert?: Enumerable<RetailerUpsertWithWhereUniqueWithoutCategorysInput>
    set?: Enumerable<RetailerWhereUniqueInput>
    disconnect?: Enumerable<RetailerWhereUniqueInput>
    delete?: Enumerable<RetailerWhereUniqueInput>
    connect?: Enumerable<RetailerWhereUniqueInput>
    update?: Enumerable<RetailerUpdateWithWhereUniqueWithoutCategorysInput>
    updateMany?: Enumerable<RetailerUpdateManyWithWhereWithoutCategorysInput>
    deleteMany?: Enumerable<RetailerScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCategoriesInput>, Enumerable<ProductUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCategoriesInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutCategoriesInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutCategoriesInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutCategoriesInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type RetailerUncheckedUpdateManyWithoutCategorysNestedInput = {
    create?: XOR<Enumerable<RetailerCreateWithoutCategorysInput>, Enumerable<RetailerUncheckedCreateWithoutCategorysInput>>
    connectOrCreate?: Enumerable<RetailerCreateOrConnectWithoutCategorysInput>
    upsert?: Enumerable<RetailerUpsertWithWhereUniqueWithoutCategorysInput>
    set?: Enumerable<RetailerWhereUniqueInput>
    disconnect?: Enumerable<RetailerWhereUniqueInput>
    delete?: Enumerable<RetailerWhereUniqueInput>
    connect?: Enumerable<RetailerWhereUniqueInput>
    update?: Enumerable<RetailerUpdateWithWhereUniqueWithoutCategorysInput>
    updateMany?: Enumerable<RetailerUpdateManyWithWhereWithoutCategorysInput>
    deleteMany?: Enumerable<RetailerScalarWhereInput>
  }

  export type ProductCreateNestedManyWithoutRetailerInput = {
    create?: XOR<Enumerable<ProductCreateWithoutRetailerInput>, Enumerable<ProductUncheckedCreateWithoutRetailerInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutRetailerInput>
    createMany?: ProductCreateManyRetailerInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type CategoryCreateNestedManyWithoutRetailersInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutRetailersInput>, Enumerable<CategoryUncheckedCreateWithoutRetailersInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutRetailersInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutRetailerInput = {
    create?: XOR<Enumerable<ProductCreateWithoutRetailerInput>, Enumerable<ProductUncheckedCreateWithoutRetailerInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutRetailerInput>
    createMany?: ProductCreateManyRetailerInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type CategoryUncheckedCreateNestedManyWithoutRetailersInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutRetailersInput>, Enumerable<CategoryUncheckedCreateWithoutRetailersInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutRetailersInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutRetailerNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutRetailerInput>, Enumerable<ProductUncheckedCreateWithoutRetailerInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutRetailerInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutRetailerInput>
    createMany?: ProductCreateManyRetailerInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutRetailerInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutRetailerInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type CategoryUpdateManyWithoutRetailersNestedInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutRetailersInput>, Enumerable<CategoryUncheckedCreateWithoutRetailersInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutRetailersInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutRetailersInput>
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutRetailersInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutRetailersInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutRetailerNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutRetailerInput>, Enumerable<ProductUncheckedCreateWithoutRetailerInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutRetailerInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutRetailerInput>
    createMany?: ProductCreateManyRetailerInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutRetailerInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutRetailerInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type CategoryUncheckedUpdateManyWithoutRetailersNestedInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutRetailersInput>, Enumerable<CategoryUncheckedCreateWithoutRetailersInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutRetailersInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutRetailersInput>
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutRetailersInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutRetailersInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type OrderCreateWithoutClientInput = {
    dateCreated?: Date | string
    confirmSuccess: boolean
    products?: ProductOnOrderCreateNestedManyWithoutOrderInput
    adress?: string
  }

  export type OrderUncheckedCreateWithoutClientInput = {
    id?: number
    dateCreated?: Date | string
    confirmSuccess: boolean
    products?: ProductOnOrderUncheckedCreateNestedManyWithoutOrderInput
    adress?: string
  }

  export type OrderCreateOrConnectWithoutClientInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput>
  }

  export type OrderCreateManyClientInputEnvelope = {
    data: Enumerable<OrderCreateManyClientInput>
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutClientInput = {
    product: ProductCreateNestedOneWithoutReviewsInput
    createdAt?: Date | string
    lastEditTime?: Date | string
    title: string
    text: string
    rating: number
    retailerAnswer?: string | null
    answerCreatedAt?: Date | string | null
  }

  export type ReviewUncheckedCreateWithoutClientInput = {
    id?: number
    productId: number
    createdAt?: Date | string
    lastEditTime?: Date | string
    title: string
    text: string
    rating: number
    retailerAnswer?: string | null
    answerCreatedAt?: Date | string | null
  }

  export type ReviewCreateOrConnectWithoutClientInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput>
  }

  export type ReviewCreateManyClientInputEnvelope = {
    data: Enumerable<ReviewCreateManyClientInput>
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutClientInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutClientInput, OrderUncheckedUpdateWithoutClientInput>
    create: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutClientInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutClientInput, OrderUncheckedUpdateWithoutClientInput>
  }

  export type OrderUpdateManyWithWhereWithoutClientInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type OrderScalarWhereInput = {
    AND?: Enumerable<OrderScalarWhereInput>
    OR?: Enumerable<OrderScalarWhereInput>
    NOT?: Enumerable<OrderScalarWhereInput>
    id?: IntFilter | number
    clientId?: IntFilter | number
    dateCreated?: DateTimeFilter | Date | string
    confirmSuccess?: BoolFilter | boolean
    adress?: StringFilter | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutClientInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutClientInput, ReviewUncheckedUpdateWithoutClientInput>
    create: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutClientInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutClientInput, ReviewUncheckedUpdateWithoutClientInput>
  }

  export type ReviewUpdateManyWithWhereWithoutClientInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutReviewsInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: Enumerable<ReviewScalarWhereInput>
    OR?: Enumerable<ReviewScalarWhereInput>
    NOT?: Enumerable<ReviewScalarWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    clientId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    lastEditTime?: DateTimeFilter | Date | string
    title?: StringFilter | string
    text?: StringFilter | string
    rating?: IntFilter | number
    retailerAnswer?: StringNullableFilter | string | null
    answerCreatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ClientCreateWithoutOrdersInput = {
    name: string
    surname: string
    email: string
    phone?: string | null
    password: string
    emailConfirmed?: boolean
    createdAt?: Date | string
    promocodes?: ClientCreatepromocodesInput | Enumerable<string>
    wishlist?: ClientCreatewishlistInput | Enumerable<number>
    reviews?: ReviewCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutOrdersInput = {
    id?: number
    name: string
    surname: string
    email: string
    phone?: string | null
    password: string
    emailConfirmed?: boolean
    createdAt?: Date | string
    promocodes?: ClientCreatepromocodesInput | Enumerable<string>
    wishlist?: ClientCreatewishlistInput | Enumerable<number>
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutOrdersInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
  }

  export type ProductOnOrderCreateWithoutOrderInput = {
    product: ProductCreateNestedOneWithoutOrdersInput
    quantity?: number
    statusCode: number
  }

  export type ProductOnOrderUncheckedCreateWithoutOrderInput = {
    id?: number
    productId: number
    quantity?: number
    statusCode: number
  }

  export type ProductOnOrderCreateOrConnectWithoutOrderInput = {
    where: ProductOnOrderWhereUniqueInput
    create: XOR<ProductOnOrderCreateWithoutOrderInput, ProductOnOrderUncheckedCreateWithoutOrderInput>
  }

  export type ProductOnOrderCreateManyOrderInputEnvelope = {
    data: Enumerable<ProductOnOrderCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutOrdersInput = {
    update: XOR<ClientUpdateWithoutOrdersInput, ClientUncheckedUpdateWithoutOrdersInput>
    create: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
  }

  export type ClientUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promocodes?: ClientUpdatepromocodesInput | Enumerable<string>
    wishlist?: ClientUpdatewishlistInput | Enumerable<number>
    reviews?: ReviewUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promocodes?: ClientUpdatepromocodesInput | Enumerable<string>
    wishlist?: ClientUpdatewishlistInput | Enumerable<number>
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ProductOnOrderUpsertWithWhereUniqueWithoutOrderInput = {
    where: ProductOnOrderWhereUniqueInput
    update: XOR<ProductOnOrderUpdateWithoutOrderInput, ProductOnOrderUncheckedUpdateWithoutOrderInput>
    create: XOR<ProductOnOrderCreateWithoutOrderInput, ProductOnOrderUncheckedCreateWithoutOrderInput>
  }

  export type ProductOnOrderUpdateWithWhereUniqueWithoutOrderInput = {
    where: ProductOnOrderWhereUniqueInput
    data: XOR<ProductOnOrderUpdateWithoutOrderInput, ProductOnOrderUncheckedUpdateWithoutOrderInput>
  }

  export type ProductOnOrderUpdateManyWithWhereWithoutOrderInput = {
    where: ProductOnOrderScalarWhereInput
    data: XOR<ProductOnOrderUpdateManyMutationInput, ProductOnOrderUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductOnOrderScalarWhereInput = {
    AND?: Enumerable<ProductOnOrderScalarWhereInput>
    OR?: Enumerable<ProductOnOrderScalarWhereInput>
    NOT?: Enumerable<ProductOnOrderScalarWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    orderId?: IntFilter | number
    quantity?: IntFilter | number
    statusCode?: IntFilter | number
  }

  export type ProductCreateWithoutOrdersInput = {
    title: string
    amount?: number
    price: number
    brand: string
    country?: string | null
    expires?: string | null
    wayToUse?: string | null
    contain?: string | null
    description: string
    storage: string
    note?: string | null
    visible?: boolean
    retailer: RetailerCreateNestedOneWithoutProductsInput
    clicks?: number
    createdAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrdersInput = {
    id?: number
    title: string
    amount?: number
    price: number
    brand: string
    country?: string | null
    expires?: string | null
    wayToUse?: string | null
    contain?: string | null
    description: string
    storage: string
    note?: string | null
    visible?: boolean
    retailerId: number
    clicks?: number
    createdAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
  }

  export type OrderCreateWithoutProductsInput = {
    client: ClientCreateNestedOneWithoutOrdersInput
    dateCreated?: Date | string
    confirmSuccess: boolean
    adress?: string
  }

  export type OrderUncheckedCreateWithoutProductsInput = {
    id?: number
    clientId: number
    dateCreated?: Date | string
    confirmSuccess: boolean
    adress?: string
  }

  export type OrderCreateOrConnectWithoutProductsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
  }

  export type ProductUpsertWithoutOrdersInput = {
    update: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
  }

  export type ProductUpdateWithoutOrdersInput = {
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    retailer?: RetailerUpdateOneRequiredWithoutProductsNestedInput
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    retailerId?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderUpsertWithoutProductsInput = {
    update: XOR<OrderUpdateWithoutProductsInput, OrderUncheckedUpdateWithoutProductsInput>
    create: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
  }

  export type OrderUpdateWithoutProductsInput = {
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmSuccess?: BoolFieldUpdateOperationsInput | boolean
    adress?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmSuccess?: BoolFieldUpdateOperationsInput | boolean
    adress?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateWithoutReviewsInput = {
    title: string
    amount?: number
    price: number
    brand: string
    country?: string | null
    expires?: string | null
    wayToUse?: string | null
    contain?: string | null
    description: string
    storage: string
    note?: string | null
    visible?: boolean
    retailer: RetailerCreateNestedOneWithoutProductsInput
    clicks?: number
    createdAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    orders?: ProductOnOrderCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutReviewsInput = {
    id?: number
    title: string
    amount?: number
    price: number
    brand: string
    country?: string | null
    expires?: string | null
    wayToUse?: string | null
    contain?: string | null
    description: string
    storage: string
    note?: string | null
    visible?: boolean
    retailerId: number
    clicks?: number
    createdAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    orders?: ProductOnOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutReviewsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
  }

  export type ClientCreateWithoutReviewsInput = {
    name: string
    surname: string
    email: string
    phone?: string | null
    password: string
    emailConfirmed?: boolean
    createdAt?: Date | string
    promocodes?: ClientCreatepromocodesInput | Enumerable<string>
    wishlist?: ClientCreatewishlistInput | Enumerable<number>
    orders?: OrderCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutReviewsInput = {
    id?: number
    name: string
    surname: string
    email: string
    phone?: string | null
    password: string
    emailConfirmed?: boolean
    createdAt?: Date | string
    promocodes?: ClientCreatepromocodesInput | Enumerable<string>
    wishlist?: ClientCreatewishlistInput | Enumerable<number>
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutReviewsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
  }

  export type ProductUpsertWithoutReviewsInput = {
    update: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
  }

  export type ProductUpdateWithoutReviewsInput = {
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    retailer?: RetailerUpdateOneRequiredWithoutProductsNestedInput
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    orders?: ProductOnOrderUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    retailerId?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    orders?: ProductOnOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ClientUpsertWithoutReviewsInput = {
    update: XOR<ClientUpdateWithoutReviewsInput, ClientUncheckedUpdateWithoutReviewsInput>
    create: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
  }

  export type ClientUpdateWithoutReviewsInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promocodes?: ClientUpdatepromocodesInput | Enumerable<string>
    wishlist?: ClientUpdatewishlistInput | Enumerable<number>
    orders?: OrderUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promocodes?: ClientUpdatepromocodesInput | Enumerable<string>
    wishlist?: ClientUpdatewishlistInput | Enumerable<number>
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
  }

  export type RetailerCreateWithoutProductsInput = {
    email: string
    emailConfirmed?: boolean
    photo: string
    name: string
    surname: string
    patrinymic: string
    phone?: string | null
    companyName: string
    city: string
    confirmed?: boolean
    password: string
    categorys?: CategoryCreateNestedManyWithoutRetailersInput
  }

  export type RetailerUncheckedCreateWithoutProductsInput = {
    id?: number
    email: string
    emailConfirmed?: boolean
    photo: string
    name: string
    surname: string
    patrinymic: string
    phone?: string | null
    companyName: string
    city: string
    confirmed?: boolean
    password: string
    categorys?: CategoryUncheckedCreateNestedManyWithoutRetailersInput
  }

  export type RetailerCreateOrConnectWithoutProductsInput = {
    where: RetailerWhereUniqueInput
    create: XOR<RetailerCreateWithoutProductsInput, RetailerUncheckedCreateWithoutProductsInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    name: string
    keywords?: CategoryCreatekeywordsInput | Enumerable<string>
    retailers?: RetailerCreateNestedManyWithoutCategorysInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    keywords?: CategoryCreatekeywordsInput | Enumerable<string>
    retailers?: RetailerUncheckedCreateNestedManyWithoutCategorysInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type ProductImageCreateWithoutProductInput = {
    path: string
    alt: string
  }

  export type ProductImageUncheckedCreateWithoutProductInput = {
    id?: number
    path: string
    alt: string
  }

  export type ProductImageCreateOrConnectWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageCreateManyProductInputEnvelope = {
    data: Enumerable<ProductImageCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutProductInput = {
    client: ClientCreateNestedOneWithoutReviewsInput
    createdAt?: Date | string
    lastEditTime?: Date | string
    title: string
    text: string
    rating: number
    retailerAnswer?: string | null
    answerCreatedAt?: Date | string | null
  }

  export type ReviewUncheckedCreateWithoutProductInput = {
    id?: number
    clientId: number
    createdAt?: Date | string
    lastEditTime?: Date | string
    title: string
    text: string
    rating: number
    retailerAnswer?: string | null
    answerCreatedAt?: Date | string | null
  }

  export type ReviewCreateOrConnectWithoutProductInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewCreateManyProductInputEnvelope = {
    data: Enumerable<ReviewCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ProductOnOrderCreateWithoutProductInput = {
    order: OrderCreateNestedOneWithoutProductsInput
    quantity?: number
    statusCode: number
  }

  export type ProductOnOrderUncheckedCreateWithoutProductInput = {
    id?: number
    orderId: number
    quantity?: number
    statusCode: number
  }

  export type ProductOnOrderCreateOrConnectWithoutProductInput = {
    where: ProductOnOrderWhereUniqueInput
    create: XOR<ProductOnOrderCreateWithoutProductInput, ProductOnOrderUncheckedCreateWithoutProductInput>
  }

  export type ProductOnOrderCreateManyProductInputEnvelope = {
    data: Enumerable<ProductOnOrderCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type RetailerUpsertWithoutProductsInput = {
    update: XOR<RetailerUpdateWithoutProductsInput, RetailerUncheckedUpdateWithoutProductsInput>
    create: XOR<RetailerCreateWithoutProductsInput, RetailerUncheckedCreateWithoutProductsInput>
  }

  export type RetailerUpdateWithoutProductsInput = {
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    patrinymic?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    categorys?: CategoryUpdateManyWithoutRetailersNestedInput
  }

  export type RetailerUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    patrinymic?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    categorys?: CategoryUncheckedUpdateManyWithoutRetailersNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateManyWithWhereWithoutProductsInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: Enumerable<CategoryScalarWhereInput>
    OR?: Enumerable<CategoryScalarWhereInput>
    NOT?: Enumerable<CategoryScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    keywords?: StringNullableListFilter
  }

  export type ProductImageUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    update: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    data: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
  }

  export type ProductImageUpdateManyWithWhereWithoutProductInput = {
    where: ProductImageScalarWhereInput
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyWithoutImagesInput>
  }

  export type ProductImageScalarWhereInput = {
    AND?: Enumerable<ProductImageScalarWhereInput>
    OR?: Enumerable<ProductImageScalarWhereInput>
    NOT?: Enumerable<ProductImageScalarWhereInput>
    id?: IntFilter | number
    path?: StringFilter | string
    alt?: StringFilter | string
    productId?: IntFilter | number
  }

  export type ReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
  }

  export type ReviewUpdateManyWithWhereWithoutProductInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutReviewsInput>
  }

  export type ProductOnOrderUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductOnOrderWhereUniqueInput
    update: XOR<ProductOnOrderUpdateWithoutProductInput, ProductOnOrderUncheckedUpdateWithoutProductInput>
    create: XOR<ProductOnOrderCreateWithoutProductInput, ProductOnOrderUncheckedCreateWithoutProductInput>
  }

  export type ProductOnOrderUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductOnOrderWhereUniqueInput
    data: XOR<ProductOnOrderUpdateWithoutProductInput, ProductOnOrderUncheckedUpdateWithoutProductInput>
  }

  export type ProductOnOrderUpdateManyWithWhereWithoutProductInput = {
    where: ProductOnOrderScalarWhereInput
    data: XOR<ProductOnOrderUpdateManyMutationInput, ProductOnOrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type ProductCreateWithoutImagesInput = {
    title: string
    amount?: number
    price: number
    brand: string
    country?: string | null
    expires?: string | null
    wayToUse?: string | null
    contain?: string | null
    description: string
    storage: string
    note?: string | null
    visible?: boolean
    retailer: RetailerCreateNestedOneWithoutProductsInput
    clicks?: number
    createdAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    orders?: ProductOnOrderCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutImagesInput = {
    id?: number
    title: string
    amount?: number
    price: number
    brand: string
    country?: string | null
    expires?: string | null
    wayToUse?: string | null
    contain?: string | null
    description: string
    storage: string
    note?: string | null
    visible?: boolean
    retailerId: number
    clicks?: number
    createdAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: ProductOnOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutImagesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
  }

  export type ProductUpsertWithoutImagesInput = {
    update: XOR<ProductUpdateWithoutImagesInput, ProductUncheckedUpdateWithoutImagesInput>
    create: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
  }

  export type ProductUpdateWithoutImagesInput = {
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    retailer?: RetailerUpdateOneRequiredWithoutProductsNestedInput
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    orders?: ProductOnOrderUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    retailerId?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: ProductOnOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutCategoriesInput = {
    title: string
    amount?: number
    price: number
    brand: string
    country?: string | null
    expires?: string | null
    wayToUse?: string | null
    contain?: string | null
    description: string
    storage: string
    note?: string | null
    visible?: boolean
    retailer: RetailerCreateNestedOneWithoutProductsInput
    clicks?: number
    createdAt?: Date | string
    images?: ProductImageCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    orders?: ProductOnOrderCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoriesInput = {
    id?: number
    title: string
    amount?: number
    price: number
    brand: string
    country?: string | null
    expires?: string | null
    wayToUse?: string | null
    contain?: string | null
    description: string
    storage: string
    note?: string | null
    visible?: boolean
    retailerId: number
    clicks?: number
    createdAt?: Date | string
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: ProductOnOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type RetailerCreateWithoutCategorysInput = {
    email: string
    emailConfirmed?: boolean
    photo: string
    name: string
    surname: string
    patrinymic: string
    phone?: string | null
    companyName: string
    city: string
    confirmed?: boolean
    password: string
    products?: ProductCreateNestedManyWithoutRetailerInput
  }

  export type RetailerUncheckedCreateWithoutCategorysInput = {
    id?: number
    email: string
    emailConfirmed?: boolean
    photo: string
    name: string
    surname: string
    patrinymic: string
    phone?: string | null
    companyName: string
    city: string
    confirmed?: boolean
    password: string
    products?: ProductUncheckedCreateNestedManyWithoutRetailerInput
  }

  export type RetailerCreateOrConnectWithoutCategorysInput = {
    where: RetailerWhereUniqueInput
    create: XOR<RetailerCreateWithoutCategorysInput, RetailerUncheckedCreateWithoutCategorysInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoriesInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    amount?: IntFilter | number
    price?: IntFilter | number
    brand?: StringFilter | string
    country?: StringNullableFilter | string | null
    expires?: StringNullableFilter | string | null
    wayToUse?: StringNullableFilter | string | null
    contain?: StringNullableFilter | string | null
    description?: StringFilter | string
    storage?: StringFilter | string
    note?: StringNullableFilter | string | null
    visible?: BoolFilter | boolean
    retailerId?: IntFilter | number
    clicks?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type RetailerUpsertWithWhereUniqueWithoutCategorysInput = {
    where: RetailerWhereUniqueInput
    update: XOR<RetailerUpdateWithoutCategorysInput, RetailerUncheckedUpdateWithoutCategorysInput>
    create: XOR<RetailerCreateWithoutCategorysInput, RetailerUncheckedCreateWithoutCategorysInput>
  }

  export type RetailerUpdateWithWhereUniqueWithoutCategorysInput = {
    where: RetailerWhereUniqueInput
    data: XOR<RetailerUpdateWithoutCategorysInput, RetailerUncheckedUpdateWithoutCategorysInput>
  }

  export type RetailerUpdateManyWithWhereWithoutCategorysInput = {
    where: RetailerScalarWhereInput
    data: XOR<RetailerUpdateManyMutationInput, RetailerUncheckedUpdateManyWithoutRetailersInput>
  }

  export type RetailerScalarWhereInput = {
    AND?: Enumerable<RetailerScalarWhereInput>
    OR?: Enumerable<RetailerScalarWhereInput>
    NOT?: Enumerable<RetailerScalarWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    emailConfirmed?: BoolFilter | boolean
    photo?: StringFilter | string
    name?: StringFilter | string
    surname?: StringFilter | string
    patrinymic?: StringFilter | string
    phone?: StringNullableFilter | string | null
    companyName?: StringFilter | string
    city?: StringFilter | string
    confirmed?: BoolFilter | boolean
    password?: StringFilter | string
  }

  export type ProductCreateWithoutRetailerInput = {
    title: string
    amount?: number
    price: number
    brand: string
    country?: string | null
    expires?: string | null
    wayToUse?: string | null
    contain?: string | null
    description: string
    storage: string
    note?: string | null
    visible?: boolean
    clicks?: number
    createdAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    orders?: ProductOnOrderCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutRetailerInput = {
    id?: number
    title: string
    amount?: number
    price: number
    brand: string
    country?: string | null
    expires?: string | null
    wayToUse?: string | null
    contain?: string | null
    description: string
    storage: string
    note?: string | null
    visible?: boolean
    clicks?: number
    createdAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: ProductOnOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRetailerInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRetailerInput, ProductUncheckedCreateWithoutRetailerInput>
  }

  export type ProductCreateManyRetailerInputEnvelope = {
    data: Enumerable<ProductCreateManyRetailerInput>
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutRetailersInput = {
    name: string
    keywords?: CategoryCreatekeywordsInput | Enumerable<string>
    products?: ProductCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutRetailersInput = {
    id?: number
    name: string
    keywords?: CategoryCreatekeywordsInput | Enumerable<string>
    products?: ProductUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryCreateOrConnectWithoutRetailersInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutRetailersInput, CategoryUncheckedCreateWithoutRetailersInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutRetailerInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutRetailerInput, ProductUncheckedUpdateWithoutRetailerInput>
    create: XOR<ProductCreateWithoutRetailerInput, ProductUncheckedCreateWithoutRetailerInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutRetailerInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutRetailerInput, ProductUncheckedUpdateWithoutRetailerInput>
  }

  export type ProductUpdateManyWithWhereWithoutRetailerInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type CategoryUpsertWithWhereUniqueWithoutRetailersInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutRetailersInput, CategoryUncheckedUpdateWithoutRetailersInput>
    create: XOR<CategoryCreateWithoutRetailersInput, CategoryUncheckedCreateWithoutRetailersInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutRetailersInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutRetailersInput, CategoryUncheckedUpdateWithoutRetailersInput>
  }

  export type CategoryUpdateManyWithWhereWithoutRetailersInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutCategorysInput>
  }

  export type OrderCreateManyClientInput = {
    id?: number
    dateCreated?: Date | string
    confirmSuccess: boolean
    adress?: string
  }

  export type ReviewCreateManyClientInput = {
    id?: number
    productId: number
    createdAt?: Date | string
    lastEditTime?: Date | string
    title: string
    text: string
    rating: number
    retailerAnswer?: string | null
    answerCreatedAt?: Date | string | null
  }

  export type OrderUpdateWithoutClientInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmSuccess?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductOnOrderUpdateManyWithoutOrderNestedInput
    adress?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmSuccess?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductOnOrderUncheckedUpdateManyWithoutOrderNestedInput
    adress?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmSuccess?: BoolFieldUpdateOperationsInput | boolean
    adress?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewUpdateWithoutClientInput = {
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    retailerAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    answerCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    retailerAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    answerCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUncheckedUpdateManyWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    retailerAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    answerCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductOnOrderCreateManyOrderInput = {
    id?: number
    productId: number
    quantity?: number
    statusCode: number
  }

  export type ProductOnOrderUpdateWithoutOrderInput = {
    product?: ProductUpdateOneRequiredWithoutOrdersNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    statusCode?: IntFieldUpdateOperationsInput | number
  }

  export type ProductOnOrderUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    statusCode?: IntFieldUpdateOperationsInput | number
  }

  export type ProductOnOrderUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    statusCode?: IntFieldUpdateOperationsInput | number
  }

  export type ProductImageCreateManyProductInput = {
    id?: number
    path: string
    alt: string
  }

  export type ReviewCreateManyProductInput = {
    id?: number
    clientId: number
    createdAt?: Date | string
    lastEditTime?: Date | string
    title: string
    text: string
    rating: number
    retailerAnswer?: string | null
    answerCreatedAt?: Date | string | null
  }

  export type ProductOnOrderCreateManyProductInput = {
    id?: number
    orderId: number
    quantity?: number
    statusCode: number
  }

  export type CategoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    keywords?: CategoryUpdatekeywordsInput | Enumerable<string>
    retailers?: RetailerUpdateManyWithoutCategorysNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    keywords?: CategoryUpdatekeywordsInput | Enumerable<string>
    retailers?: RetailerUncheckedUpdateManyWithoutCategorysNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    keywords?: CategoryUpdatekeywordsInput | Enumerable<string>
  }

  export type ProductImageUpdateWithoutProductInput = {
    path?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
  }

  export type ProductImageUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
  }

  export type ProductImageUncheckedUpdateManyWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewUpdateWithoutProductInput = {
    client?: ClientUpdateOneRequiredWithoutReviewsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    retailerAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    answerCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    retailerAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    answerCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductOnOrderUpdateWithoutProductInput = {
    order?: OrderUpdateOneRequiredWithoutProductsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    statusCode?: IntFieldUpdateOperationsInput | number
  }

  export type ProductOnOrderUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    statusCode?: IntFieldUpdateOperationsInput | number
  }

  export type ProductOnOrderUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    statusCode?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpdateWithoutCategoriesInput = {
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    retailer?: RetailerUpdateOneRequiredWithoutProductsNestedInput
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ProductImageUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    orders?: ProductOnOrderUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    retailerId?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: ProductOnOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    retailerId?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetailerUpdateWithoutCategorysInput = {
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    patrinymic?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutRetailerNestedInput
  }

  export type RetailerUncheckedUpdateWithoutCategorysInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    patrinymic?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutRetailerNestedInput
  }

  export type RetailerUncheckedUpdateManyWithoutRetailersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    patrinymic?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateManyRetailerInput = {
    id?: number
    title: string
    amount?: number
    price: number
    brand: string
    country?: string | null
    expires?: string | null
    wayToUse?: string | null
    contain?: string | null
    description: string
    storage: string
    note?: string | null
    visible?: boolean
    clicks?: number
    createdAt?: Date | string
  }

  export type ProductUpdateWithoutRetailerInput = {
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    orders?: ProductOnOrderUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutRetailerInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableStringFieldUpdateOperationsInput | string | null
    wayToUse?: NullableStringFieldUpdateOperationsInput | string | null
    contain?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    storage?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: ProductOnOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CategoryUpdateWithoutRetailersInput = {
    name?: StringFieldUpdateOperationsInput | string
    keywords?: CategoryUpdatekeywordsInput | Enumerable<string>
    products?: ProductUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutRetailersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    keywords?: CategoryUpdatekeywordsInput | Enumerable<string>
    products?: ProductUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutCategorysInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    keywords?: CategoryUpdatekeywordsInput | Enumerable<string>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}